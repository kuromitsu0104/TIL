# 概要<!-- omit in toc -->

- 書籍名
  - プログラミングTypeScript
- 学習用リポジトリ
  - https://github.com/kuromitsu0104/programming-typescript

# 目次<!-- omit in toc -->

- [1章 イントロダクション](#1章-イントロダクション)
- [2章 TypeScript：全体像](#2章-typescript全体像)
  - [2.1 コンパイラー](#21-コンパイラー)
  - [2.2 型システム](#22-型システム)
    - [2.2.1 TypeScript対JavaScript](#221-typescript対javascript)
  - [2.3 コードエディターのセットアップ](#23-コードエディターのセットアップ)
    - [2.3.1 tsconfig.json](#231-tsconfigjson)
    - [2.3.2 tslint.json](#232-tslintjson)
  - [2.4 index.ts](#24-indexts)
  - [2.5 練習問題](#25-練習問題)
- [3章 型について](#3章-型について)
  - [3.1 型についての議論](#31-型についての議論)
    - [3.2 型の初歩](#32-型の初歩)
    - [3.2.1 any](#321-any)
    - [3.2.2 unknown](#322-unknown)
    - [3.2.3 boolean](#323-boolean)
    - [3.2.4 number](#324-number)
    - [3.2.5 bigint](#325-bigint)
    - [3.2.6 string](#326-string)
    - [3.2.7 symbol](#327-symbol)
    - [3.2.8 オブジェクト](#328-オブジェクト)
    - [3.2.9 型エイリアス、合併、交差](#329-型エイリアス合併交差)
    - [3.2.10 配列](#3210-配列)
    - [3.2.11 タプル](#3211-タプル)
    - [3.2.12 null、undefined、void、never](#3212-nullundefinedvoidnever)
    - [3.2.13 列挙型](#3213-列挙型)
  - [3.3 まとめ](#33-まとめ)
  - [3.4 練習問題](#34-練習問題)
- [4章 関数](#4章-関数)
  - [4.1 関数の宣言と呼び出し](#41-関数の宣言と呼び出し)
    - [4.1.1 オプションパラメーターとデフォルトパラメーター](#411-オプションパラメーターとデフォルトパラメーター)
    - [4.1.2 レストパラメーター](#412-レストパラメーター)
    - [4.1.3 call、apply、bind](#413-callapplybind)
    - [4.1.4 thisの型付け](#414-thisの型付け)
    - [4.1.5 ジェネレーター](#415-ジェネレーター)
    - [4.1.6 イテレーター](#416-イテレーター)
    - [4.1.7 呼び出しシグネチャ](#417-呼び出しシグネチャ)
    - [4.1.8 文脈的型付け](#418-文脈的型付け)
    - [4.1.9 オーバーロードされた関数の型](#419-オーバーロードされた関数の型)
  - [4.2 ポリモーフィズム](#42-ポリモーフィズム)
    - [4.2.1 ジェネリックはいつバインドされるか？](#421-ジェネリックはいつバインドされるか)
    - [4.2.2 ジェネリックはどこで宣言できるか？](#422-ジェネリックはどこで宣言できるか)
    - [4.2.3 ジェネリックの型推論](#423-ジェネリックの型推論)
    - [4.2.4 ジェネリック型エイリアス](#424-ジェネリック型エイリアス)
    - [4.2.5 制限付きポリモーフィズム](#425-制限付きポリモーフィズム)
    - [4.2.6 ジェネリック型のデフォルトの型](#426-ジェネリック型のデフォルトの型)
  - [4.3 型駆動開発](#43-型駆動開発)
  - [4.4 まとめ](#44-まとめ)
  - [4.5 練習問題](#45-練習問題)
- [5章 クラスとインターフェース](#5章-クラスとインターフェース)
  - [5.1 クラスと継承](#51-クラスと継承)
  - [5.2 super](#52-super)
  - [5.3 戻り値の型としてthisを使用する](#53-戻り値の型としてthisを使用する)
  - [5.4 インターフェース](#54-インターフェース)
    - [5.4.1 宣言のマージ](#541-宣言のマージ)
    - [5.4.2 実装](#542-実装)
    - [5.4.3 「インターフェースの実装」対「抽象クラスの拡張」](#543-インターフェースの実装対抽象クラスの拡張)
  - [5.5 クラスは構造的に型付けされる](#55-クラスは構造的に型付けされる)
  - [5.6 クラスは値と型の両方を宣言する](#56-クラスは値と型の両方を宣言する)
  - [5.7 ポリモーフィズム](#57-ポリモーフィズム)
  - [5.8 ミックスイン](#58-ミックスイン)
  - [5.9 デコレーター](#59-デコレーター)
  - [5.10 finalクラスをシミュレートする](#510-finalクラスをシミュレートする)
  - [5.11 デザインパターン](#511-デザインパターン)
    - [5.11.1 ファクトリーパターン](#5111-ファクトリーパターン)
    - [5.11.2 ビルダーパターン](#5112-ビルダーパターン)
  - [5.12 まとめ](#512-まとめ)
  - [5.13 練習問題](#513-練習問題)
- [6章 高度な型](#6章-高度な型)
  - [6.1 型の間の関係](#61-型の間の関係)
    - [6.1.1 サブタイプとスーパータイプ](#611-サブタイプとスーパータイプ)
    - [6.1.2 変性](#612-変性)
    - [6.1.3 割り当て可能性](#613-割り当て可能性)
    - [6.1.4 型の拡大](#614-型の拡大)
    - [6.1.5 型の絞り込み](#615-型の絞り込み)
  - [6.2 完全性](#62-完全性)
  - [6.3 高度なオブジェクト型](#63-高度なオブジェクト型)
    - [6.3.1 オブジェクト型についての型演算子](#631-オブジェクト型についての型演算子)
    - [6.3.2 レコード型](#632-レコード型)
    - [6.3.3 マップ型](#633-マップ型)
    - [6.3.4 コンパニオンオブジェクトパターン](#634-コンパニオンオブジェクトパターン)
  - [6.4 関数にまつわる高度な型](#64-関数にまつわる高度な型)
    - [6.4.1 タプルについての型推論の改善](#641-タプルについての型推論の改善)
    - [6.4.2 ユーザー定義型ガード](#642-ユーザー定義型ガード)
  - [6.5 条件型](#65-条件型)
    - [6.5.1 分配条件型](#651-分配条件型)
    - [6.5.2 inferキーワード](#652-inferキーワード)
    - [6.5.3 組み込みの条件型](#653-組み込みの条件型)
  - [6.6 エスケープハッチ](#66-エスケープハッチ)
    - [6.6.1 型アサーション](#661-型アサーション)
    - [6.6.2 非nullアサーション](#662-非nullアサーション)
    - [6.6.3 明確な割り当てアサーション](#663-明確な割り当てアサーション)
  - [6.7 名前的型をシミュレートする](#67-名前的型をシミュレートする)
  - [6.8 プロトタイプを安全に拡張する](#68-プロトタイプを安全に拡張する)
  - [6.9 まとめ](#69-まとめ)
  - [6.10 練習問題](#610-練習問題)
- [7章 エラー処理](#7章-エラー処理)
  - [7.1 nullを返す](#71-nullを返す)
  - [7.2 例外をスローする](#72-例外をスローする)
  - [7.3 例外を返す](#73-例外を返す)
  - [7.4 Option型](#74-option型)
  - [7.5 まとめ](#75-まとめ)
  - [7.6 練習問題](#76-練習問題)
- [8章 非同期プログラミングと並行、並列処理](#8章-非同期プログラミングと並行並列処理)
  - [8.1 JavaScriptのイベントループ](#81-javascriptのイベントループ)
  - [8.2 コールバックの処理](#82-コールバックの処理)
  - [8.3 プロミスを使って健全さを取り戻す](#83-プロミスを使って健全さを取り戻す)
  - [8.4 asyncとawait](#84-asyncとawait)
  - [8.5 非同期ストリーム](#85-非同期ストリーム)
  - [8.5.1 イベントエミッター](#851-イベントエミッター)
  - [8.6 型安全なマルチスレッディング](#86-型安全なマルチスレッディング)
    - [8.6.1 Web Worker（ブラウザー）](#861-web-workerブラウザー)
    - [8.6.2 子プロセス（Node.js）](#862-子プロセスnodejs)
  - [8.7 まとめ](#87-まとめ)
  - [8.8 練習問題](#88-練習問題)
- [9章 フロントエンドとバックエンドのフレームワーク](#9章-フロントエンドとバックエンドのフレームワーク)
  - [9.1 フロントエンドのフレームワーク](#91-フロントエンドのフレームワーク)
    - [9.1.1 React](#911-react)
    - [9.1.2 Angular 6/7](#912-angular-67)
  - [9.2 型安全なAPI](#92-型安全なapi)
  - [9.3 バックエンドのフレームワーク](#93-バックエンドのフレームワーク)
  - [9.4 まとめ](#94-まとめ)
- [10章 名前空間とモジュール](#10章-名前空間とモジュール)
  - [10.1 JavaScriptモジュールの簡単な歴史](#101-javascriptモジュールの簡単な歴史)
  - [10.2 インポート、エクスポート](#102-インポートエクスポート)
    - [10.2.1 動的インポート](#1021-動的インポート)
    - [10.2.2 CommonJSおよびAMDコードの使用](#1022-commonjsおよびamdコードの使用)
    - [10.2.3 モジュールモードとスクリプトモード](#1023-モジュールモードとスクリプトモード)
  - [10.3 名前空間](#103-名前空間)
    - [10.3.1 競合](#1031-競合)
    - [10.3.2 コンパイルされた出力結果](#1032-コンパイルされた出力結果)
  - [10.4 宣言のマージ](#104-宣言のマージ)
  - [10.5 まとめ](#105-まとめ)
  - [10.6 練習問題](#106-練習問題)
- [11章 JavaScriptとの相互運用](#11章-javascriptとの相互運用)
  - [11.1 型宣言](#111-型宣言)
    - [11.1.1 アンビエント変数宣言](#1111-アンビエント変数宣言)
    - [11.1.2 アンビエント型宣言](#1112-アンビエント型宣言)
    - [11.1.3 アンビエントモジュール宣言](#1113-アンビエントモジュール宣言)
  - [11.2 JavaScriptからTypeScriptへの漸進的な移行](#112-javascriptからtypescriptへの漸進的な移行)
    - [11.2.1 ステップ1：TSCを追加する](#1121-ステップ1tscを追加する)
    - [11.2.2 ステップ2a：JavaScriptの型チェックを有効にする（オプション）](#1122-ステップ2ajavascriptの型チェックを有効にするオプション)
    - [11.2.3 ステップ2b：JSDocアノテーションを追加する（オプション）](#1123-ステップ2bjsdocアノテーションを追加するオプション)
    - [11.2.4 ステップ3：ファイルを.tsにリネームする](#1124-ステップ3ファイルをtsにリネームする)
    - [11.2.5 ステップ4：厳格にする](#1125-ステップ4厳格にする)
  - [11.3 JavaScriptの型の探索](#113-javascriptの型の探索)
    - [11.3.1 JavaScriptファイルが同一プロジェクト内に存在する場合](#1131-javascriptファイルが同一プロジェクト内に存在する場合)
    - [11.3.2 サードパーティーのJavaScriptモジュールを利用する場合](#1132-サードパーティーのjavascriptモジュールを利用する場合)
  - [11.4 サードパーティーJavaScriptの使用](#114-サードパーティーjavascriptの使用)
    - [11.4.1 型宣言を備えているJavaScript](#1141-型宣言を備えているjavascript)
    - [11.4.2 DefinitelyTypedに型宣言を持つJavaScript](#1142-definitelytypedに型宣言を持つjavascript)
    - [11.4.3 DefinitelyTypedに型宣言を持たないJavaScript](#1143-definitelytypedに型宣言を持たないjavascript)
  - [11.5 まとめ](#115-まとめ)
- [12章 TypeScriptのビルドと実行](#12章-typescriptのビルドと実行)
  - [12.1 TypeScriptプロジェクトのビルド](#121-typescriptプロジェクトのビルド)
    - [12.1.1 プロジェクトのレイアウト](#1211-プロジェクトのレイアウト)
    - [12.1.2 成果物](#1212-成果物)
    - [12.1.3 コンパイルターゲットの指定](#1213-コンパイルターゲットの指定)
    - [12.1.4 ソースマップを有効にする](#1214-ソースマップを有効にする)
    - [12.1.5 プロジェクト参照](#1215-プロジェクト参照)
    - [12.1.6 エラーの監視](#1216-エラーの監視)
  - [12.2 TypeScriptをサーバー上で実行する](#122-typescriptをサーバー上で実行する)
  - [12.3 TypeScriptをブラウザー内で実行する](#123-typescriptをブラウザー内で実行する)
  - [12.4 TypeScriptコードをnpmに公開する](#124-typescriptコードをnpmに公開する)
  - [12.5 トリプルスラッシュ・ディレクティブ](#125-トリプルスラッシュディレクティブ)
    - [12.5.1 typesディレクティブ](#1251-typesディレクティブ)
    - [12.5.2 amd-moduleディレクティブ](#1252-amd-moduleディレクティブ)
  - [12.6 まとめ](#126-まとめ)
- [13章 終わりに](#13章-終わりに)

# 1章 イントロダクション

# 2章 TypeScript：全体像

## 2.1 コンパイラー

- TypeScriptのソースコードのコンパイル順序

  ```mermaid
  graph LR
    subgraph TS
      style A text-align:left
      A["1. TypeScriptソース -> TypeScript AST<br>
         2. ASTが型チェッカーによってチェックされる<br>
         3. TypeScript AST -> JavaScriptソース"]
    end

    subgraph JS
      style B text-align:left
      B["1. JavaScriptソース -> JavaScript AST<br>
         2. AST -> バイトコード<br>
         3. バイトコードがランタイムによって評価される"]
    end

    A --> B
  ```

## 2.2 型システム

- アノテーション

  ```ts
  let a: number = 1 // a is number.
  ```

- 推論

  ```ts
  let a = 1 // a is number.
  ```

### 2.2.1 TypeScript対JavaScript

- TypeScript = 漸進的型付き言語

## 2.3 コードエディターのセットアップ

### 2.3.1 tsconfig.json

### 2.3.2 tslint.json

## 2.4 index.ts

## 2.5 練習問題

# 3章 型について

## 3.1 型についての議論

### 3.2 型の初歩

### 3.2.1 any

### 3.2.2 unknown

### 3.2.3 boolean

### 3.2.4 number

### 3.2.5 bigint

### 3.2.6 string

### 3.2.7 symbol

```ts
let a = Symbol('a') // symbol
let b: symbol = Symbol('b') // symbol
```

- symbol型は一意となる
- 同じ値のsymbol型でも一致しない

  ```ts
  let a = Symbol('a') // symbol
  let b = Symbol('a') // symbol
  console.log(a === b) //=> false
  ```

### 3.2.8 オブジェクト

- TypeScriptではプロパティの型が一致すれば、同じ型扱いとなる

  ```ts
  let c: {
    firstName: string
    lastName: string
  } = {
    firstName: 'john',
    lastName: 'barrowman',
  }

  class Person {
    firstName: string
    lastName: string

    constructor(firstName: string, lastName: string) {
      this.firstName = firstName
      this.lastName = lastName
    }
  }

  c = new Person('matt', 'smith') // c変数の型にマッチするため代入可能
  ```

- string || undefined なプロパティ

  ```ts
  let a: {
    b?: string
    c: string
  } = {
    b: 'hoge'
    c: 'fuga'
  }
  ```

- インデックスシグネチャ

  - 任意のキーを持つプロパティを任意の数だけ持たせる

  ```ts
  let a: {
    [key: number]: boolean
  } = {
    12: true,
    24: false,
  }
  ```

- readonly

  - 読み取り専用のプロパティ

  ```ts
  let user: {
    readonly firstName: string
  } = {
    firstName = 'hoge', // ok
  }

  user.firstname = 'fuga' // error
  ```

### 3.2.9 型エイリアス、合併、交差

- 型エイリアス

  ```ts
  type Age = number
  type Person = {
    name: string
    age: Age // Ageはnumberのエイリアス
  }

  let age: Age = 20
  let driver: Person = {
    name: 'hoge',
    age: age, // Age型とnumber型を割り当て可能
  }
  ```

  - 型エイリアスの目的
    - 複雑な型定義をDRYにする
    - 型を命名することで可読性を高める

- 合併型と交差型

  - 型定義の例

    ```ts
    type Kick = {
      effect: boolean
      hit: boolean
    }

    type Punch = {
      hit: boolean
      damage: number
    }

    type KickOrPunch = Kick | Punch
    type KickAndPunch = Kick & Punch
    ```

  - 合併型

    ```ts
    // 合併型なので、Kick, Punch型両方のプロパティが使える
    const SuperAtack: KickOrPunch = {
      effect: true,
      hit: true,
      damage: 10,
    }

    // 合併型なため、どちらかの型ということを表せれば良い
    const normalAtack: KickOrPunch = {
      hit: true,
      damage: 3,
    }

    // 交差型なので、合併型同様Kick, Punch型両方のプロパティが使える
    const doubleAtack: KickAndPunch = {
      effect: true,
      hit: true,
      damage: 10,
    }
    ```

  - 交差型
    ```ts
    // 交差型は集合元の型全てのプロパティを使わなくてはならない
    const errorNormalAtack: KickAndPunch = {
      hit: true,
      damage: 3,
    }
    // エラー: Kick typeのeffectプロパティがないため
    ```

### 3.2.10 配列

- TypeScriptで配列を取り扱う時の注意点
  - 配列内の全ての要素が同じ型を持つようにプログラムを設計すること

### 3.2.11 タプル

- タプル(tuple)は配列のサブタイプ(派生型)

  - 固定長の配列を型付けするための方法

    ```ts
    let a: [number, string] = [1, '1']
    a = [2, '2']
    ```

  - 省略オブションも存在する

    ```ts
    let a: [number, string?][] = [[1, '1']]
    a = [[2, '2'], [3]]
    ```

  - 可変長の要素にも対応

    - 空配列の可能性のある数値を持つ配列

      ```ts
      let numbers: [...number[]] = []
      numbers = [1]
      ```

    - 少なくとも1つ以上の数値を持つ配列

      ```ts
      let numbers: [number, ...number[]] = [1, 2, 3, 4]
      numbers = [] // error
      ```

    - 不均一なリスト

      ```ts
      let uneven_list: [string, boolean, ...numbers[]] = ['1', true, 2]
      uneven_list = ['2', false]
      ```

- タプル型のメリット

  - 不均一なリストを安全にコード化できること
  - リスト長を限定できること

- readonly修飾子

  - 配列の要素を読み取り専用にして変更できないようにする
  - 読み取り専用の配列

    ```ts
    let a: readonly number[] = [1, 2, 3]
    a = [5] // error
    ```

  - 読み取り専用のタプル

    ```ts
    let a: readonly [...number] = [1, 2, 3]
    a = [] // error
    ```

### 3.2.12 null、undefined、void、never

- undefined: 未定義であること（値がまだ割り当てられていない変数）
- null: 値が欠如していること（値の欠如）
- void: 明示的に何も返却しない関数の型のこと（return文を持たない関数の戻り値）
  - 例: `#console.log`
- never: 決して値を戻すことのない関数の型のこと（決して戻ることのない関数の戻り値）
  - 例: 例外返却、無限ループ

### 3.2.13 列挙型

- enum(列挙型)は、慣習として大文字で始まる単数系で表す

  ```ts
  enum Language {
    Japanese,
    English,
    Spanish,
  }
  ```

- `const enum`で危険なアクセスを防ぐ

  - constを使用しない場合

    ```ts
    enum Language {
      Japanese,
      English,
      Spanish,
    }

    Language[4] // エラーは発生せず、undefinedを返却する（危険な挙動）
    ```

  - constを使用する場合

    ```ts
    enum Language {
      Japanese,
      English,
      Spanish,
    }

    Language[4] // error
    ```

- 列挙型は安全に使用することが難しいため利用を控えるべき
- constでないenumは論外

## 3.3 まとめ

## 3.4 練習問題

# 4章 関数

## 4.1 関数の宣言と呼び出し

- パラメータのアノテーションは必須（推論してくれない）

  ```ts
  function add(a: number, b: number) {
    return a + b
  }
  ```

- 戻り値のアノテーションは任意（推論してくれる）

  - 戻り値を推論させる

    ```ts
    function add(a: number, b: number) {
      return a + b
    }
    ```

  - 戻り値をアノテーションする

    ```ts
    function add(a: number, b: number): number {
      return a + b
    }
    ```

- 関数を宣言する方法

  - 名前付き関数

    ```ts
    function greet(name: string) {
      return name
    }
    ```

  - 関数式

    ```ts
    let greet = function (name: string) {
      return name
    }
    ```

  - アロー関数式

    ```ts
    let greet = (name: string) => {
      return name
    }
    ```

  - アロー関数式の省略記法

    ```ts
    let greet = (name: string) => name
    ```

  - 関数コンストラクター(非推奨)

    ```ts
    let greet = new Function('name', 'return name')
    ```

- 用語
  - パラメータ（仮パラメータ）
    - 関数宣言の一部として宣言するもの
    - 引数の値でパラメータは初期化される
  - 引数（実パラメータ）
    - 関数を呼び出すときに渡すデータのこと

### 4.1.1 オプションパラメーターとデフォルトパラメーター

- オプショナルパラメータを利用する場合

  ```ts
  function log(message: string, userId?: string) {
    ...
  }

  log('メッセージ', '1234')
  log('メッセージ') // オプショナルな引数の受け渡しは任意
  ```

- デフォルトパラメータを利用する場合

  ```ts
  function log(message: string, userId = 'Not Signed in') {
    ...
  } // オプショナルなアノテーションが不要になる

  log('メッセージ', '1234')
  log('メッセージ') // デフォルト値を利用
  ```

- デフォルトパラメータをアノテーションする場合

  ```ts
  type Context = {
    userId?: string
    appId?: string
  }

  function log(message: string, context: Context = {}) {
    ...
  }

  log('メッセージ', { userId: '1234', appId: '5678' })
  log('メッセージ') // デフォルト値を利用
  ```

- オプションパラメータよりも、デフォルトパラメータを利用することが多い

### 4.1.2 レストパラメーター

### 4.1.3 call、apply、bind

### 4.1.4 thisの型付け

### 4.1.5 ジェネレーター

### 4.1.6 イテレーター

### 4.1.7 呼び出しシグネチャ

### 4.1.8 文脈的型付け

### 4.1.9 オーバーロードされた関数の型

## 4.2 ポリモーフィズム

### 4.2.1 ジェネリックはいつバインドされるか？

### 4.2.2 ジェネリックはどこで宣言できるか？

### 4.2.3 ジェネリックの型推論

### 4.2.4 ジェネリック型エイリアス

### 4.2.5 制限付きポリモーフィズム

### 4.2.6 ジェネリック型のデフォルトの型

## 4.3 型駆動開発

## 4.4 まとめ

## 4.5 練習問題

# 5章 クラスとインターフェース

## 5.1 クラスと継承

## 5.2 super

## 5.3 戻り値の型としてthisを使用する

## 5.4 インターフェース

### 5.4.1 宣言のマージ

### 5.4.2 実装

### 5.4.3 「インターフェースの実装」対「抽象クラスの拡張」

## 5.5 クラスは構造的に型付けされる

## 5.6 クラスは値と型の両方を宣言する

## 5.7 ポリモーフィズム

## 5.8 ミックスイン

## 5.9 デコレーター

## 5.10 finalクラスをシミュレートする

## 5.11 デザインパターン

### 5.11.1 ファクトリーパターン

### 5.11.2 ビルダーパターン

## 5.12 まとめ

## 5.13 練習問題

# 6章 高度な型

## 6.1 型の間の関係

### 6.1.1 サブタイプとスーパータイプ

### 6.1.2 変性

### 6.1.3 割り当て可能性

### 6.1.4 型の拡大

### 6.1.5 型の絞り込み

## 6.2 完全性

## 6.3 高度なオブジェクト型

### 6.3.1 オブジェクト型についての型演算子

### 6.3.2 レコード型

### 6.3.3 マップ型

### 6.3.4 コンパニオンオブジェクトパターン

## 6.4 関数にまつわる高度な型

### 6.4.1 タプルについての型推論の改善

### 6.4.2 ユーザー定義型ガード

## 6.5 条件型

### 6.5.1 分配条件型

### 6.5.2 inferキーワード

### 6.5.3 組み込みの条件型

## 6.6 エスケープハッチ

### 6.6.1 型アサーション

### 6.6.2 非nullアサーション

### 6.6.3 明確な割り当てアサーション

## 6.7 名前的型をシミュレートする

## 6.8 プロトタイプを安全に拡張する

## 6.9 まとめ

## 6.10 練習問題

# 7章 エラー処理

## 7.1 nullを返す

## 7.2 例外をスローする

## 7.3 例外を返す

## 7.4 Option型

## 7.5 まとめ

## 7.6 練習問題

# 8章 非同期プログラミングと並行、並列処理

## 8.1 JavaScriptのイベントループ

## 8.2 コールバックの処理

## 8.3 プロミスを使って健全さを取り戻す

## 8.4 asyncとawait

## 8.5 非同期ストリーム

## 8.5.1 イベントエミッター

## 8.6 型安全なマルチスレッディング

### 8.6.1 Web Worker（ブラウザー）

### 8.6.2 子プロセス（Node.js）

## 8.7 まとめ

## 8.8 練習問題

# 9章 フロントエンドとバックエンドのフレームワーク

## 9.1 フロントエンドのフレームワーク

### 9.1.1 React

### 9.1.2 Angular 6/7

## 9.2 型安全なAPI

## 9.3 バックエンドのフレームワーク

## 9.4 まとめ

# 10章 名前空間とモジュール

## 10.1 JavaScriptモジュールの簡単な歴史

## 10.2 インポート、エクスポート

### 10.2.1 動的インポート

### 10.2.2 CommonJSおよびAMDコードの使用

### 10.2.3 モジュールモードとスクリプトモード

## 10.3 名前空間

### 10.3.1 競合

### 10.3.2 コンパイルされた出力結果

## 10.4 宣言のマージ

## 10.5 まとめ

## 10.6 練習問題

# 11章 JavaScriptとの相互運用

## 11.1 型宣言

### 11.1.1 アンビエント変数宣言

### 11.1.2 アンビエント型宣言

### 11.1.3 アンビエントモジュール宣言

## 11.2 JavaScriptからTypeScriptへの漸進的な移行

### 11.2.1 ステップ1：TSCを追加する

### 11.2.2 ステップ2a：JavaScriptの型チェックを有効にする（オプション）

### 11.2.3 ステップ2b：JSDocアノテーションを追加する（オプション）

### 11.2.4 ステップ3：ファイルを.tsにリネームする

### 11.2.5 ステップ4：厳格にする

## 11.3 JavaScriptの型の探索

### 11.3.1 JavaScriptファイルが同一プロジェクト内に存在する場合

### 11.3.2 サードパーティーのJavaScriptモジュールを利用する場合

## 11.4 サードパーティーJavaScriptの使用

### 11.4.1 型宣言を備えているJavaScript

### 11.4.2 DefinitelyTypedに型宣言を持つJavaScript

### 11.4.3 DefinitelyTypedに型宣言を持たないJavaScript

## 11.5 まとめ

# 12章 TypeScriptのビルドと実行

## 12.1 TypeScriptプロジェクトのビルド

### 12.1.1 プロジェクトのレイアウト

### 12.1.2 成果物

### 12.1.3 コンパイルターゲットの指定

### 12.1.4 ソースマップを有効にする

### 12.1.5 プロジェクト参照

### 12.1.6 エラーの監視

## 12.2 TypeScriptをサーバー上で実行する

## 12.3 TypeScriptをブラウザー内で実行する

## 12.4 TypeScriptコードをnpmに公開する

## 12.5 トリプルスラッシュ・ディレクティブ

### 12.5.1 typesディレクティブ

### 12.5.2 amd-moduleディレクティブ

## 12.6 まとめ

# 13章 終わりに

```

```
