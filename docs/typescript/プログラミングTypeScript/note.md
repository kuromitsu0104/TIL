# 1章 イントロダクション

# 2章 TypeScript：全体像

## 2.1 コンパイラー

## 2.2 型システム

### 2.2.1 TypeScript対JavaScript

## 2.3 コードエディターのセットアップ

### 2.3.1 tsconfig.json

### 2.3.2 tslint.json

## 2.4 index.ts

## 2.5 練習問題

# 3章 型について

## 3.1 型についての議論

### 3.2 型の初歩

### 3.2.1 any

### 3.2.2 unknown

### 3.2.3 boolean

### 3.2.4 number

### 3.2.5 bigint

### 3.2.6 string

### 3.2.7 symbol

### 3.2.8 オブジェクト

### 3.2.9 型エイリアス、合併、交差

### 3.2.10 配列

### 3.2.11 タプル

### 3.2.12 null、undefined、void、never

### 3.2.13 列挙型

## 3.3 まとめ

## 3.4 練習問題

# 4章 関数

## 4.1 関数の宣言と呼び出し

### 4.1.1 オプションパラメーターとデフォルトパラメーター

### 4.1.2 レストパラメーター

### 4.1.3 call、apply、bind

### 4.1.4 thisの型付け

### 4.1.5 ジェネレーター

### 4.1.6 イテレーター

### 4.1.7 呼び出しシグネチャ

### 4.1.8 文脈的型付け

### 4.1.9 オーバーロードされた関数の型

## 4.2 ポリモーフィズム

### 4.2.1 ジェネリックはいつバインドされるか？

### 4.2.2 ジェネリックはどこで宣言できるか？

### 4.2.3 ジェネリックの型推論

### 4.2.4 ジェネリック型エイリアス

### 4.2.5 制限付きポリモーフィズム

### 4.2.6 ジェネリック型のデフォルトの型

## 4.3 型駆動開発

## 4.4 まとめ

## 4.5 練習問題

# 5章 クラスとインターフェース

## 5.1 クラスと継承

## 5.2 super

## 5.3 戻り値の型としてthisを使用する

## 5.4 インターフェース

### 5.4.1 宣言のマージ

### 5.4.2 実装

### 5.4.3 「インターフェースの実装」対「抽象クラスの拡張」

## 5.5 クラスは構造的に型付けされる

## 5.6 クラスは値と型の両方を宣言する

## 5.7 ポリモーフィズム

## 5.8 ミックスイン

## 5.9 デコレーター

## 5.10 finalクラスをシミュレートする

## 5.11 デザインパターン

### 5.11.1 ファクトリーパターン

### 5.11.2 ビルダーパターン

## 5.12 まとめ

## 5.13 練習問題

# 6章 高度な型

## 6.1 型の間の関係

### 6.1.1 サブタイプとスーパータイプ

### 6.1.2 変性

### 6.1.3 割り当て可能性

### 6.1.4 型の拡大

### 6.1.5 型の絞り込み

## 6.2 完全性

## 6.3 高度なオブジェクト型

### 6.3.1 オブジェクト型についての型演算子

### 6.3.2 レコード型

### 6.3.3 マップ型

### 6.3.4 コンパニオンオブジェクトパターン

## 6.4 関数にまつわる高度な型

### 6.4.1 タプルについての型推論の改善

### 6.4.2 ユーザー定義型ガード

## 6.5 条件型

### 6.5.1 分配条件型

### 6.5.2 inferキーワード

### 6.5.3 組み込みの条件型

## 6.6 エスケープハッチ

### 6.6.1 型アサーション

### 6.6.2 非nullアサーション

### 6.6.3 明確な割り当てアサーション

## 6.7 名前的型をシミュレートする

## 6.8 プロトタイプを安全に拡張する

## 6.9 まとめ

## 6.10 練習問題

# 7章 エラー処理

## 7.1 nullを返す

## 7.2 例外をスローする

## 7.3 例外を返す

## 7.4 Option型

## 7.5 まとめ

## 7.6 練習問題

# 8章 非同期プログラミングと並行、並列処理

## 8.1 JavaScriptのイベントループ

## 8.2 コールバックの処理

## 8.3 プロミスを使って健全さを取り戻す

## 8.4 asyncとawait

## 8.5 非同期ストリーム

## 8.5.1 イベントエミッター

## 8.6 型安全なマルチスレッディング

### 8.6.1 Web Worker（ブラウザー）

### 8.6.2 子プロセス（Node.js）

## 8.7 まとめ

## 8.8 練習問題

# 9章 フロントエンドとバックエンドのフレームワーク

## 9.1 フロントエンドのフレームワーク

### 9.1.1 React

### 9.1.2 Angular 6/7

## 9.2 型安全なAPI

## 9.3 バックエンドのフレームワーク

## 9.4 まとめ

# 10章 名前空間とモジュール

## 10.1 JavaScriptモジュールの簡単な歴史

## 10.2 インポート、エクスポート

### 10.2.1 動的インポート

### 10.2.2 CommonJSおよびAMDコードの使用

### 10.2.3 モジュールモードとスクリプトモード

## 10.3 名前空間

### 10.3.1 競合

### 10.3.2 コンパイルされた出力結果

## 10.4 宣言のマージ

## 10.5 まとめ

## 10.6 練習問題

# 11章 JavaScriptとの相互運用

## 11.1 型宣言

### 11.1.1 アンビエント変数宣言

### 11.1.2 アンビエント型宣言

### 11.1.3 アンビエントモジュール宣言

## 11.2 JavaScriptからTypeScriptへの漸進的な移行

### 11.2.1 ステップ1：TSCを追加する

### 11.2.2 ステップ2a：JavaScriptの型チェックを有効にする（オプション）

### 11.2.3 ステップ2b：JSDocアノテーションを追加する（オプション）

### 11.2.4 ステップ3：ファイルを.tsにリネームする

### 11.2.5 ステップ4：厳格にする

## 11.3 JavaScriptの型の探索

### 11.3.1 JavaScriptファイルが同一プロジェクト内に存在する場合

### 11.3.2 サードパーティーのJavaScriptモジュールを利用する場合

## 11.4 サードパーティーJavaScriptの使用

### 11.4.1 型宣言を備えているJavaScript

### 11.4.2 DefinitelyTypedに型宣言を持つJavaScript

### 11.4.3 DefinitelyTypedに型宣言を持たないJavaScript

## 11.5 まとめ

# 12章 TypeScriptのビルドと実行

## 12.1 TypeScriptプロジェクトのビルド

### 12.1.1 プロジェクトのレイアウト

### 12.1.2 成果物

### 12.1.3 コンパイルターゲットの指定

### 12.1.4 ソースマップを有効にする

### 12.1.5 プロジェクト参照

### 12.1.6 エラーの監視

## 12.2 TypeScriptをサーバー上で実行する

## 12.3 TypeScriptをブラウザー内で実行する

## 12.4 TypeScriptコードをnpmに公開する

## 12.5 トリプルスラッシュ・ディレクティブ

### 12.5.1 typesディレクティブ

### 12.5.2 amd-moduleディレクティブ

## 12.6 まとめ

# 13章 終わりに
