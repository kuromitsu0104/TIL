# 概要

## 本

- SQL アンチパターン

# はじめに

アンチパターンの種類

- データベースの論理設計のアンチパターン
- データベースの物理設計のアンチぱｔーん
- クエリのアンチパターン

# Part:1 ジェイウォーク(信号無視)

- 「多対多」の交差テーブルの作成をさけるため、カンマ区切りでひとつのカラムに複数の値を格納すること

## 1.1 目的: 複数の値を持つ属性を格納する

## 1.2 アンチパターン: カンマ区切りフォーマットのリストを格納する

- うまくいっているように見えるが、パフォーマンス上の問題やデータ整合性の問題が発生

## 1.2.1 特定アカウントに関連する製品の検索

- 等価性による比較ができず、文字列パターンマッチが必要
- パターンマッチは意図しないレコードとマッチする可能性があるのと、インデックスによるメリットを得られない

## 1.2.2 特定製品に関連するアカウントの検索

- すべてのレコードで文字列をスキャン必要があり、インデックスを利用できない

## 1.2.3 集約クエリの作成

- 集約クエリはカンマ区切りのために作られておらず、クエリ作成で小細工が必要

## 1.2.4 特定の製品に関連するアカウントの更新

- リストのソート順を維持できない

## 1.2.5 アカウント ID の妥当性検証

- データ型による制約がないため、想定外の値が混入し得る

## 1.2.6 区切り文字の選択

- 格納したい値にカンマが含まれる可能性が考えられる
- この場合、区切り文字として何を扱うのか検討しなければならない。しかも、完全に対策できない場合が多い

## 1.2.7 リストの長さの制限

- 最大文字数をどのように決めるべきか
- 最大文字数によって格納できるリスト数が変動してしまう

## 1.3 アンチパターンの見つけ方

- 「このリストでサポートしなくてはならない最大のエントリ数は？」
  - カラムの最大文字数を決めようとしているとき
- 「SQL で単語境界を一致させる方法をしってる？」
  - カラム内の文字列を正規表現で取得しようとしているとき
  - 取得しようとしている要素を別カラムなどに格納した方がいい兆候
- 「リストのエントリに絶対使われない文字ってなんだっけ？」
  - 区切り文字を探しているとき
  - いかなる値もいつか使われる可能性があることを肝に銘じるべき

## 1.4 アンチパターンを用いてもよい場合

- クエリのパフォーマンス向上のため、データベース構造を非正規化することがある
- 基本は正規化

## 1.5 解決策: 交差テーブルを作成する

- テーブルが 2 つのテーブルを参照する外部キーを持つ => 交差(インターセクション: intersection)テーブルと呼ばれる
- N:N, 多対多

## 1.5.1 特定のアカウントに関連する製品の検索 / 特定の製品に関連するアカウントの検索

- INNER JOIN で検索可能
- インデックス利用可能

## 1.5.2 集約クエリの作成

- GROUP BY, COUNT などを使ったシンプルなクエリを実行可能

## 1.5.3 製品の連絡先の更新

## 1.5.4 アカウント ID の妥当性検証

- データ型による制約が可能

## 1.5.5 区切り文字の選択

- 区切り文字が不要

## 1.5.6 リストの長さの制限

## 1.5.7 交差テーブルの他のメリット

- 外部キーでインデックスを用いることでパフォーマンスが向上
- 各エンティティのカラムに属性を保持可能

# Part2: ナイーブツリー(素朴な木)

- 親子関係のあるコメント機能を実装するときに発生
- 階層構造をどのように保持するべきか

## 2.1 目的: 階層構造を格納し、クエリを実行する

- ツリー構造
  - ノード
    - 各エントリのこと
    - ひとつ以上の親、ひとつ以上の子を持つことができる
  - 根(ルート)
    - 親を持たないノードのこと
    - 最上位のノード
  - 葉(リーフ)
    - 子を持たないノードのこと
    - 最下層のノード
  - 非葉ノード
    - 親と子を持つノードのこと
    - 中間ノード
- ツリー指向のデータ構造の代表例
  - 組織図
    - 従業員の上下関係
  - スレッド形式のコメント欄(掲示板)
    - 親コメントとリプライコメントの関係

## 2.2 アンチパターン: 常に親のみに依存する

- 隣接リストと呼ばれる手法
- 各エントリに`parent_id`を持たせる
- `parent_id`には`comment_id`を入力
  ![](/docs/database_design/sql_antipatterns/images/20220829_004341.jpg)
  ![](/docs/database_design/sql_antipatterns/images/20220829_004841.jpg)

## 2.2.1 隣接リストへのクエリ実行

- 多段ネストしたエンティティの場合、再帰的なクエリ実行が必要
  - 子モデルの parent_id と一致するレコードを取得して, 取得したレコードの parent_id と一致する...
  - ネストの数だけ JOIN しなければならない
- 大量データの取得となるため非効率

## 2.2.2 隣接リストのツリーのメンテナンス

- 葉ノードの追加は簡単
- ただし、ノードの削除が非常に厄介
  - 葉ノードから削除せねばならない
  - 非葉ノードの削除が大変
  - ノードの昇格が大変
    - 非葉ノード -> 葉ノード, 根ノードなどに遷移すること
- 1 階層だけなら運用できそうだが、階層制限がない場合は致命的な問題となり得る

## 2.3 アンチパターンの見つけ方

- 「このツリーでは、深さを何階層までサポートすればいい？」
  - 再帰的なクエリの実装に苦心していて、階層数に制限を設けようとしている
- 「ツリー型のデータ構造を扱うコードなんて２度と書きたくないな」
  - 最善策を選択したつもりだが、作業の進捗が芳しくない
  - 他の方法を検討するべき
- 「ツリーの中で孤児になった行を綺麗にするために、定期的にスクリプトを実行しなければ」
  - データの整合性を保つようなクエリを実行できていない

## 2.4 アンチパターンを用いてもよい場合

- アンチパターンを用いても良い条件
  - ノードの直近の親と子を取得するだけであること
  - 列の挿入のみであること
  - エントリの削除をしないこと
- 「再帰クエリ構文」を使うことでクエリをシンプルにできる

## 2.5 解決策: 代替ツリーモデルを使用する

## 2.5.1 経路列挙(Path Enumeration)

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_222552.jpg)
- メリット
  - 先祖ノードのパスを属性に格納することで、隣接リストの弱点(先祖ノードの取得効率が悪い)を解消
- デメリット
  - パスの構造や成形を DB の制約で保証できない
  - カラムの最大文字数による制限

## 2.5.2 入れ子集合(Nested Set)

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_223316.jpg)
  ![](/docs/database_design/sql_antipatterns/images/20220914_224106.jpg)
- メリット
  - サブツリーに対する迅速かつ容易なクエリ実行が得意
- デメリット
  - ノードの挿入や移動には不向き。関連ノードの左右値の再計算が必要で複雑になるため。
- 非葉ノードの削除、追加が複雑
  - 追加
    - left_id, right_id をそれぞれ再計算して更新して間を空けてからレコードを挿入
  - 削除
    - レコードを削除してから、left_id, right_id を再計算して更新

## 2.5.3 閉包テーブル(Closure Table)

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_225212.jpg)
- ツリー構造の path を格納するテーブルを用意する方法
- 閉包テーブルの見方
  - 先祖 == 子孫
    - カレントノード
  - 先祖 > 子孫
    - 先祖と子孫の関係
    - 差が 1 のときは直接の親子関係となる
  - 先祖 < 子孫
    - 先祖と子孫の関係
    - 差が 1 のときは直接の親子関係となる
- ノード自体を削除せずに関連付けのみ変更することも可能

## 2.5.4 どの設計を使うべきか

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_231309.jpg)
- 再帰リスト
  - 最もポピュラーな選択肢であるが、階層が深いと使いづらい
- 再帰クエリ
  - WITH, CONNECT BY PRIOR 構文を用いることで、再帰リストの計算効率を高められる
- 経路列挙
  - 参照整合性を保証できない(存在しないノードを参照できてしまう)
- 入れ子集合
  - 難しい。参照整合性を保証できない
  - ツリーの修正には不向き
  - ツリーの検索には向いている
- 閉包テーブル
  - 最も用途が幅広い
  - ひとつのノードが複数のツリーに所属可能

## Part3: ID リクワイアド(とりあえず ID)

### 3.1 目的: 主キーの規約を確立する

- 用語
  - 主キー(primary key)
  - 外部キー(foreign key)
  - 擬似キー(pseudo key)
  - 代理キー(surrogate key)
- 重複排除のためにも主キーは必須

### 3.2 アンチパターン: すべてのテーブルに「id」列を用いる

- 意図に反した影響が生じる可能性あり

### 3.2.1 冗長なキーが作成されてしまう

- 主キーとして利用できそうなカラムが存在していても、慣習を重視して id カラムを追加してしまう

### 3.2.2 重複行を許可してしまう

- 複合キー(compound key): 複数の列で構成されるキー
- 交差テーブルでよく用いられる
- 複合キーで重複確認すべきケースで id カラムで重複確認してしまうと重複行が発生してしまう

### 3.2.3 キーの意味がわかりにくくなる

### 3.2.4 USING を使用する

- USING
  - JOIN 構文の ON のシンタックスシュガー
  - 同じカラムをキーとして結合する場合に USING で簡潔に記述可能

### 3.2.5 複合キーは使いにくい

### 3.3 アンチパターンの見つけ方

- テーブルの主キーの列名が「id」であるとき
  - ID リクワイアド(とりあえず ID)
- このテーブルでは主キーは不要だと思うとき
  - 重複行を防ぐために主キー制約は必須。主キーには自然キーや複合キーでも可

### 3.4 アンチパターンを用いてもよい場合

- ORM のような設定より規約の原則に従う場合には、主キーを「id」としても良い

### 3.5 解決策: 状況に応じて適切に調整する

- 主キーは制約であり、データ型ではない

### 3.5.1 わかりやすい列名にしよう

- Bugs テーブルの主キー: bug_id
- 複数テーブルで主キーに同じ名前を使うべきでない

### 3.5.2 規約に縛られない

- ActiveRecord のような ORM でも主キーの規約の上書きが可能

### 3.5.3 自然キーと複合キーの活用

- 自然キーを主キーとしていたが、重複が発生するようになった場合の対策
  - 代理キーを追加して、自然キー＋代理キーによる複合主キーを使う

## Part4: キーレスエントリ(外部キー嫌い)

### 4.1 目的: データベースのアーキテクチャを単純化する

- テーブル間のリレーションシップの設計が重要
- 特に、参照整合性が重要
- 外部キー制約には親テーブルのユニークキーが必須

### 4.2 アンチパターン: 外部キー制約を使用しない

### 4.2.1 完璧なコードを前提にしている

- 参照生合成を保証するようなソースコードを書かなければならない
- 「100 万分の 1 の確率で生じることは、次の火曜日に起きる」という言葉がある

### 4.2.2 ミスを調べなければならない

- 不整合な値を抽出するスクリプトなどを作成したりして、データの整合性を調べなければならない
-
