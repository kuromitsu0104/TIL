# 概要<!-- omit in toc -->

- 書籍名

  - SQL アンチパターン

# 目次<!-- omit in toc -->

- [Part1: ジェイウォーク(信号無視)](#part1-ジェイウォーク信号無視)
  - [1.1 目的: 複数の値を持つ属性を格納する](#11-目的-複数の値を持つ属性を格納する)
  - [1.2 アンチパターン: カンマ区切りフォーマットのリストを格納する](#12-アンチパターン-カンマ区切りフォーマットのリストを格納する)
  - [1.2.1 特定アカウントに関連する製品の検索](#121-特定アカウントに関連する製品の検索)
  - [1.2.2 特定製品に関連するアカウントの検索](#122-特定製品に関連するアカウントの検索)
  - [1.2.3 集約クエリの作成](#123-集約クエリの作成)
  - [1.2.4 特定の製品に関連するアカウントの更新](#124-特定の製品に関連するアカウントの更新)
  - [1.2.5 アカウント ID の妥当性検証](#125-アカウント-id-の妥当性検証)
  - [1.2.6 区切り文字の選択](#126-区切り文字の選択)
  - [1.2.7 リストの長さの制限](#127-リストの長さの制限)
  - [1.3 アンチパターンの見つけ方](#13-アンチパターンの見つけ方)
  - [1.4 アンチパターンを用いてもよい場合](#14-アンチパターンを用いてもよい場合)
  - [1.5 解決策: 交差テーブルを作成する](#15-解決策-交差テーブルを作成する)
  - [1.5.1 特定のアカウントに関連する製品の検索 / 特定の製品に関連するアカウントの検索](#151-特定のアカウントに関連する製品の検索--特定の製品に関連するアカウントの検索)
  - [1.5.2 集約クエリの作成](#152-集約クエリの作成)
  - [1.5.3 製品の連絡先の更新](#153-製品の連絡先の更新)
  - [1.5.4 アカウント ID の妥当性検証](#154-アカウント-id-の妥当性検証)
  - [1.5.5 区切り文字の選択](#155-区切り文字の選択)
  - [1.5.6 リストの長さの制限](#156-リストの長さの制限)
  - [1.5.7 交差テーブルの他のメリット](#157-交差テーブルの他のメリット)
- [Part2: ナイーブツリー(素朴な木)](#part2-ナイーブツリー素朴な木)
  - [2.1 目的: 階層構造を格納し、クエリを実行する](#21-目的-階層構造を格納しクエリを実行する)
  - [2.2 アンチパターン: 常に親のみに依存する](#22-アンチパターン-常に親のみに依存する)
  - [2.2.1 隣接リストへのクエリ実行](#221-隣接リストへのクエリ実行)
  - [2.2.2 隣接リストのツリーのメンテナンス](#222-隣接リストのツリーのメンテナンス)
  - [2.3 アンチパターンの見つけ方](#23-アンチパターンの見つけ方)
  - [2.4 アンチパターンを用いてもよい場合](#24-アンチパターンを用いてもよい場合)
  - [2.5 解決策: 代替ツリーモデルを使用する](#25-解決策-代替ツリーモデルを使用する)
  - [2.5.1 経路列挙(Path Enumeration)](#251-経路列挙path-enumeration)
  - [2.5.2 入れ子集合(Nested Set)](#252-入れ子集合nested-set)
  - [2.5.3 閉包テーブル(Closure Table)](#253-閉包テーブルclosure-table)
  - [2.5.4 どの設計を使うべきか](#254-どの設計を使うべきか)
- [Part3: ID リクワイアド(とりあえず ID)](#part3-id-リクワイアドとりあえず-id)
  - [3.1 目的: 主キーの規約を確立する](#31-目的-主キーの規約を確立する)
  - [3.2 アンチパターン: すべてのテーブルに「id」列を用いる](#32-アンチパターン-すべてのテーブルにid列を用いる)
  - [3.2.1 冗長なキーが作成されてしまう](#321-冗長なキーが作成されてしまう)
  - [3.2.2 重複行を許可してしまう](#322-重複行を許可してしまう)
  - [3.2.3 キーの意味がわかりにくくなる](#323-キーの意味がわかりにくくなる)
  - [3.2.4 USING を使用する](#324-using-を使用する)
  - [3.2.5 複合キーは使いにくい](#325-複合キーは使いにくい)
  - [3.3 アンチパターンの見つけ方](#33-アンチパターンの見つけ方)
  - [3.4 アンチパターンを用いてもよい場合](#34-アンチパターンを用いてもよい場合)
  - [3.5 解決策: 状況に応じて適切に調整する](#35-解決策-状況に応じて適切に調整する)
  - [3.5.1 わかりやすい列名にしよう](#351-わかりやすい列名にしよう)
  - [3.5.2 規約に縛られない](#352-規約に縛られない)
  - [3.5.3 自然キーと複合キーの活用](#353-自然キーと複合キーの活用)
- [Part4: キーレスエントリ(外部キー嫌い)](#part4-キーレスエントリ外部キー嫌い)
  - [4.1 目的: データベースのアーキテクチャを単純化する](#41-目的-データベースのアーキテクチャを単純化する)
  - [4.2 アンチパターン: 外部キー制約を使用しない](#42-アンチパターン-外部キー制約を使用しない)
  - [4.2.1 完璧なコードを前提にしている](#421-完璧なコードを前提にしている)
  - [4.2.2 ミスを調べなければならない](#422-ミスを調べなければならない)
  - [4.2.3 「私のミスではありません！」](#423-私のミスではありません)
  - [4.2.4 「キャッチ =22」な UPDATE](#424-キャッチ-22な-update)
  - [4.3 アンチパターンの見つけ方](#43-アンチパターンの見つけ方)
  - [4.4 アンチパターンを用いてもよい場合](#44-アンチパターンを用いてもよい場合)
  - [4.5 解決策: 外部キー制約を宣言する](#45-解決策-外部キー制約を宣言する)
  - [4.5.1 複数テーブルの変更をサポートする](#451-複数テーブルの変更をサポートする)
  - [4.5.2 オーバーヘッド、…にはならない](#452-オーバーヘッドにはならない)
- [Part5: EAV(エンティティ・アトリビュート・バリュー)](#part5-eavエンティティアトリビュートバリュー)
  - [5.1 目的: 可変属性をサポートする](#51-目的-可変属性をサポートする)
  - [5.2.1 属性を取得するにはどうするのか](#521-属性を取得するにはどうするのか)
  - [5.2.2 データ整合性をどう保つか](#522-データ整合性をどう保つか)
    - [必須属性を設定できない](#必須属性を設定できない)
    - [SQL のデータ型を使えない](#sql-のデータ型を使えない)
    - [参照整合性を矯正できない](#参照整合性を矯正できない)
    - [属性名を補わなければならない](#属性名を補わなければならない)
  - [5.2.3 行を再構築しなければならない](#523-行を再構築しなければならない)
  - [5.3 アンチパターンの見つけ方](#53-アンチパターンの見つけ方)
  - [5.4 アンチパターンを用いてもよい場合](#54-アンチパターンを用いてもよい場合)
  - [5.5 解決策: サブタイプのモデリングを行う](#55-解決策-サブタイプのモデリングを行う)
  - [5.5.1 シングルテーブル継承](#551-シングルテーブル継承)
  - [5.5.2 具象テーブル継承](#552-具象テーブル継承)
  - [5.5.3 クラステーブル継承](#553-クラステーブル継承)
  - [5.5.4 半構造化データ](#554-半構造化データ)
  - [5.5.5 後処理](#555-後処理)
- [Part6: ポリモーフィック関連](#part6-ポリモーフィック関連)
  - [アンチパターン: 二重目的の外部キーを使用する](#アンチパターン-二重目的の外部キーを使用する)
  - [ポリモーフィック関連を定義する](#ポリモーフィック関連を定義する)
  - [データへのメタデータ混入 が諸悪の根源](#データへのメタデータ混入-が諸悪の根源)
  - [アンチパターンの見つけ方](#アンチパターンの見つけ方)
  - [ポリモーフィック関連を用いてもよい場合](#ポリモーフィック関連を用いてもよい場合)
  - [解決策: 関連(リレーションシップ)を単純化する](#解決策-関連リレーションシップを単純化する)
    - [参照を逆にする](#参照を逆にする)
    - [交差テーブルの作成](#交差テーブルの作成)
    - [交差点に交通信号を設置する](#交差点に交通信号を設置する)
    - [共通の親テーブルの作成](#共通の親テーブルの作成)
- [Part7: マルチカラムアトリビュート(複数列属性)](#part7-マルチカラムアトリビュート複数列属性)
  - [アンチパターン: 複数の列を定義する](#アンチパターン-複数の列を定義する)
    - [値の検索](#値の検索)
    - [値の追加と削除](#値の追加と削除)
    - [一意性の保証](#一意性の保証)
    - [増加する値の処理](#増加する値の処理)
  - [アンチパターンの見つけ方](#アンチパターンの見つけ方-1)
  - [アンチパターンを使ってもよい場合](#アンチパターンを使ってもよい場合)
  - [解決策: 従属テーブルを作成する](#解決策-従属テーブルを作成する)
- [Part8: メタデータトリブル(メタデータ大増殖)](#part8-メタデータトリブルメタデータ大増殖)

# Part1: ジェイウォーク(信号無視)

- 「多対多」の交差テーブルの作成をさけるため、カンマ区切りでひとつのカラムに複数の値を格納すること

## 1.1 目的: 複数の値を持つ属性を格納する

## 1.2 アンチパターン: カンマ区切りフォーマットのリストを格納する

- うまくいっているように見えるが、パフォーマンス上の問題やデータ整合性の問題が発生

## 1.2.1 特定アカウントに関連する製品の検索

- 等価性による比較ができず、文字列パターンマッチが必要
- パターンマッチは意図しないレコードとマッチする可能性があるのと、インデックスによるメリットを得られない

## 1.2.2 特定製品に関連するアカウントの検索

- すべてのレコードで文字列をスキャン必要があり、インデックスを利用できない

## 1.2.3 集約クエリの作成

- 集約クエリはカンマ区切りのために作られておらず、クエリ作成で小細工が必要

## 1.2.4 特定の製品に関連するアカウントの更新

- リストのソート順を維持できない

## 1.2.5 アカウント ID の妥当性検証

- データ型による制約がないため、想定外の値が混入し得る

## 1.2.6 区切り文字の選択

- 格納したい値にカンマが含まれる可能性が考えられる
- この場合、区切り文字として何を扱うのか検討しなければならない。しかも、完全に対策できない場合が多い

## 1.2.7 リストの長さの制限

- 最大文字数をどのように決めるべきか
- 最大文字数によって格納できるリスト数が変動してしまう

## 1.3 アンチパターンの見つけ方

- 「このリストでサポートしなくてはならない最大のエントリ数は？」
  - カラムの最大文字数を決めようとしているとき
- 「SQL で単語境界を一致させる方法をしってる？」
  - カラム内の文字列を正規表現で取得しようとしているとき
  - 取得しようとしている要素を別カラムなどに格納した方がいい兆候
- 「リストのエントリに絶対使われない文字ってなんだっけ？」
  - 区切り文字を探しているとき
  - いかなる値もいつか使われる可能性があることを肝に銘じるべき

## 1.4 アンチパターンを用いてもよい場合

- クエリのパフォーマンス向上のため、データベース構造を非正規化することがある
- 基本は正規化

## 1.5 解決策: 交差テーブルを作成する

- テーブルが 2 つのテーブルを参照する外部キーを持つ => 交差(インターセクション: intersection)テーブルと呼ばれる
- N:N, 多対多

## 1.5.1 特定のアカウントに関連する製品の検索 / 特定の製品に関連するアカウントの検索

- INNER JOIN で検索可能
- インデックス利用可能

## 1.5.2 集約クエリの作成

- GROUP BY, COUNT などを使ったシンプルなクエリを実行可能

## 1.5.3 製品の連絡先の更新

## 1.5.4 アカウント ID の妥当性検証

- データ型による制約が可能

## 1.5.5 区切り文字の選択

- 区切り文字が不要

## 1.5.6 リストの長さの制限

## 1.5.7 交差テーブルの他のメリット

- 外部キーでインデックスを用いることでパフォーマンスが向上
- 各エンティティのカラムに属性を保持可能

# Part2: ナイーブツリー(素朴な木)

- 親子関係のあるコメント機能を実装するときに発生
- 階層構造をどのように保持するべきか

## 2.1 目的: 階層構造を格納し、クエリを実行する

- ツリー構造
  - ノード
    - 各エントリのこと
    - ひとつ以上の親、ひとつ以上の子を持つことができる
  - 根(ルート)
    - 親を持たないノードのこと
    - 最上位のノード
  - 葉(リーフ)
    - 子を持たないノードのこと
    - 最下層のノード
  - 非葉ノード
    - 親と子を持つノードのこと
    - 中間ノード
- ツリー指向のデータ構造の代表例
  - 組織図
    - 従業員の上下関係
  - スレッド形式のコメント欄(掲示板)
    - 親コメントとリプライコメントの関係

## 2.2 アンチパターン: 常に親のみに依存する

- 隣接リストと呼ばれる手法
- 各エントリに`parent_id`を持たせる
- `parent_id`には`comment_id`を入力
  ![](/docs/database_design/sql_antipatterns/images/20220829_004341.jpg)
  ![](/docs/database_design/sql_antipatterns/images/20220829_004841.jpg)

## 2.2.1 隣接リストへのクエリ実行

- 多段ネストしたエンティティの場合、再帰的なクエリ実行が必要
  - 子モデルの parent_id と一致するレコードを取得して, 取得したレコードの parent_id と一致する...
  - ネストの数だけ JOIN しなければならない
- 大量データの取得となるため非効率

## 2.2.2 隣接リストのツリーのメンテナンス

- 葉ノードの追加は簡単
- ただし、ノードの削除が非常に厄介
  - 葉ノードから削除せねばならない
  - 非葉ノードの削除が大変
  - ノードの昇格が大変
    - 非葉ノード -> 葉ノード, 根ノードなどに遷移すること
- 1 階層だけなら運用できそうだが、階層制限がない場合は致命的な問題となり得る

## 2.3 アンチパターンの見つけ方

- 「このツリーでは、深さを何階層までサポートすればいい？」
  - 再帰的なクエリの実装に苦心していて、階層数に制限を設けようとしている
- 「ツリー型のデータ構造を扱うコードなんて２度と書きたくないな」
  - 最善策を選択したつもりだが、作業の進捗が芳しくない
  - 他の方法を検討するべき
- 「ツリーの中で孤児になった行を綺麗にするために、定期的にスクリプトを実行しなければ」
  - データの整合性を保つようなクエリを実行できていない

## 2.4 アンチパターンを用いてもよい場合

- アンチパターンを用いても良い条件
  - ノードの直近の親と子を取得するだけであること
  - 列の挿入のみであること
  - エントリの削除をしないこと
- 「再帰クエリ構文」を使うことでクエリをシンプルにできる

## 2.5 解決策: 代替ツリーモデルを使用する

## 2.5.1 経路列挙(Path Enumeration)

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_222552.jpg)
- メリット
  - 先祖ノードのパスを属性に格納することで、隣接リストの弱点(先祖ノードの取得効率が悪い)を解消
- デメリット
  - パスの構造や成形を DB の制約で保証できない
  - カラムの最大文字数による制限

## 2.5.2 入れ子集合(Nested Set)

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_223316.jpg)
  ![](/docs/database_design/sql_antipatterns/images/20220914_224106.jpg)
- メリット
  - サブツリーに対する迅速かつ容易なクエリ実行が得意
- デメリット
  - ノードの挿入や移動には不向き。関連ノードの左右値の再計算が必要で複雑になるため。
- 非葉ノードの削除、追加が複雑
  - 追加
    - left_id, right_id をそれぞれ再計算して更新して間を空けてからレコードを挿入
  - 削除
    - レコードを削除してから、left_id, right_id を再計算して更新

## 2.5.3 閉包テーブル(Closure Table)

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_225212.jpg)
- ツリー構造の path を格納するテーブルを用意する方法
- 閉包テーブルの見方
  - 先祖 == 子孫
    - カレントノード
  - 先祖 > 子孫
    - 先祖と子孫の関係
    - 差が 1 のときは直接の親子関係となる
  - 先祖 < 子孫
    - 先祖と子孫の関係
    - 差が 1 のときは直接の親子関係となる
- ノード自体を削除せずに関連付けのみ変更することも可能

## 2.5.4 どの設計を使うべきか

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220914_231309.jpg)
- 再帰リスト
  - 最もポピュラーな選択肢であるが、階層が深いと使いづらい
- 再帰クエリ
  - WITH, CONNECT BY PRIOR 構文を用いることで、再帰リストの計算効率を高められる
- 経路列挙
  - 参照整合性を保証できない(存在しないノードを参照できてしまう)
- 入れ子集合
  - 難しい。参照整合性を保証できない
  - ツリーの修正には不向き
  - ツリーの検索には向いている
- 閉包テーブル
  - 最も用途が幅広い
  - ひとつのノードが複数のツリーに所属可能

# Part3: ID リクワイアド(とりあえず ID)

## 3.1 目的: 主キーの規約を確立する

- 用語
  - 主キー(primary key)
  - 外部キー(foreign key)
  - 擬似キー(pseudo key)
  - 代理キー(surrogate key)
- 重複排除のためにも主キーは必須

## 3.2 アンチパターン: すべてのテーブルに「id」列を用いる

- 意図に反した影響が生じる可能性あり

## 3.2.1 冗長なキーが作成されてしまう

- 主キーとして利用できそうなカラムが存在していても、慣習を重視して id カラムを追加してしまう

## 3.2.2 重複行を許可してしまう

- 複合キー(compound key): 複数の列で構成されるキー
- 交差テーブルでよく用いられる
- 複合キーで重複確認すべきケースで id カラムで重複確認してしまうと重複行が発生してしまう

## 3.2.3 キーの意味がわかりにくくなる

## 3.2.4 USING を使用する

- USING
  - JOIN 構文の ON のシンタックスシュガー
  - 同じカラムをキーとして結合する場合に USING で簡潔に記述可能

## 3.2.5 複合キーは使いにくい

## 3.3 アンチパターンの見つけ方

- テーブルの主キーの列名が「id」であるとき
  - ID リクワイアド(とりあえず ID)
- このテーブルでは主キーは不要だと思うとき
  - 重複行を防ぐために主キー制約は必須。主キーには自然キーや複合キーでも可

## 3.4 アンチパターンを用いてもよい場合

- ORM のような設定より規約の原則に従う場合には、主キーを「id」としても良い

## 3.5 解決策: 状況に応じて適切に調整する

- 主キーは制約であり、データ型ではない

## 3.5.1 わかりやすい列名にしよう

- Bugs テーブルの主キー: bug_id
- 複数テーブルで主キーに同じ名前を使うべきでない

## 3.5.2 規約に縛られない

- ActiveRecord のような ORM でも主キーの規約の上書きが可能

## 3.5.3 自然キーと複合キーの活用

- 自然キーを主キーとしていたが、重複が発生するようになった場合の対策
  - 代理キーを追加して、自然キー＋代理キーによる複合主キーを使う

# Part4: キーレスエントリ(外部キー嫌い)

## 4.1 目的: データベースのアーキテクチャを単純化する

- テーブル間のリレーションシップの設計が重要
- 特に、参照整合性が重要
- 外部キー制約には親テーブルのユニークキーが必須

## 4.2 アンチパターン: 外部キー制約を使用しない

## 4.2.1 完璧なコードを前提にしている

- 参照生合成を保証するようなソースコードを書かなければならない
- 「100 万分の 1 の確率で生じることは、次の火曜日に起きる」という言葉がある

## 4.2.2 ミスを調べなければならない

- 不整合な値を抽出するスクリプトなどを作成したりして、データの整合性を調べなければならない

## 4.2.3 「私のミスではありません！」

- データベースにまつわる処理が完璧であることはない
- DB の制約により整合性を守るべき

## 4.2.4 「キャッチ =22」な UPDATE

- 親子レコードを同時に更新する必要があるときにエラー発生

## 4.3 アンチパターンの見つけ方

- 「あるテーブルには存在するけど、もう一つのテーブルには存在しない鯛を調べるクエリは、どう書けばいい？」
  - 親レコードの削除や更新により、孤児となったレコードを調べようとしている
- 「あるテーブルの値が、別のテーブルへの挿入に使われていることを簡単にチェックする方法はある？」
  - 親レコードの存在チェックをしようとしている
- 「外部キー？データベースの実行速度を遅くするから、使ってはならないと教わったのだけど」
  - 外部キー省略によるデメリットや、省略によるパフォーマンス低下の影響のほうが大きい

## 4.4 アンチパターンを用いてもよい場合

- 外部キー制約を利用できない DBMS を利用しているとき

## 4.5 解決策: 外部キー制約を宣言する

- 外部キー制約によりデータ不整合を発生させない
- データ投入時点でエラーが発生するようにすることで、ミスを阻止できる

## 4.5.1 複数テーブルの変更をサポートする

- カスケード更新
  - ON UPDATE 句
  - ON DELETE 句
- RESTRICT
- SET DEFAULT

## 4.5.2 オーバーヘッド、…にはならない

- 外部キー制約のメリット
  - 挿入、更新、削除の前に、SELECT クエリの実行が不要
  - 孤児レコードが生じない
- パフォーマンス向上、参照整合性の維持に役立つ

# Part5: EAV(エンティティ・アトリビュート・バリュー)

## 5.1 目的: 可変属性をサポートする

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220917_173358.jpg)
  ![](/docs/database_design/sql_antipatterns/images/20220917_173409.jpg)
- エンティティの属性を別テーブルに切り出す設計のことを、エンティティ・アトリビュート・バリュー(EAV)と呼ぶ
- EAV テーブルのカラム
  - id
    - 外部キー制約
  - entitiy
    - 属性の名前
  - value
    - 属性の値
- EAV のメリット
  - エンティティの列数を減らせる
  - エンティティの属性を簡単に追加可能

## 5.2.1 属性を取得するにはどうするのか

## 5.2.2 データ整合性をどう保つか

### 必須属性を設定できない

- SQL では、特定の値を持つレコードが存在すること、のような制約をかけることができない
- つまり、NOT NULL 制約を宣言できない

### SQL のデータ型を使えない

- VARCHAR 型で値を投入することしかできず、属性に応じたデータ型を利用できない
- アプリケーション側の実装したいで、データ型の不整合が生じてしまう

### 参照整合性を矯正できない

- 従来型のデータベースの場合だと、外部キー制約による参照整合性により、一部の属性の値に制限をかけることができた
- EAV の場合だと、全ての属性に対して外部キー制約による参照整合性が動作するため使い物にならない

### 属性名を補わなければならない

- 属性名に制約がないため、意図せず同じ用途で別名の属性名が利用される可能性がある
- EAV の場合、属性名は動的に増えていくものであり、静的に値を定義しておき制約をかけることも難しい

## 5.2.3 行を再構築しなければならない

- 従来型のデータベースのように１行に全ての属性を持つレコードを取得したい場合
  - 外部結合(OUTER JOIN)を属性ごとに実行しなければならない
  - 属性数が増加するたびに、指数関数的にコストが増加する

## 5.3 アンチパターンの見つけ方

- 「このデータベースは、メタデータの変更なしで拡張可能だ。実行時に新しい属性を定義できる」
  - RDB には柔軟性がないため、EAV 設計を用いている可能性大
- 「クエリは、結合を最大いくつまでサポートしているんだっけ？」
  - 大量の結合を行おうとしており、EAV がよく直面する問題である

## 5.4 アンチパターンを用いてもよい場合

- EAV を正当化する理由はほぼない
- RDB 以外の方法で実現するべき要件である可能性大
  - ドキュメント指向データベースなどの KVS が代替となる

## 5.5 解決策: サブタイプのモデリングを行う

- EAV の代替策を RDB で実現できるパターン
  - サブタイプの数が限られ、開発者が各サブタイプの属性をよく知っているとき
  - これ以外は不可能

## 5.5.1 シングルテーブル継承

- すべてのサブタイプの属性を列に追加して、一つのテーブルに格納する方法
- ER
  ```
  - 全てのサブタイプを許容する単一テーブル
  ```
- デメリット
  - 新しいサブタイプが必要なときは、テーブル定義を更新して列を追加する必要あり
  - 列数が RDB の上限と衝突する可能性あり
- 使い所
  - サブタイプ数が少ないときに有効
  - ActiveRecord でも有効

## 5.5.2 具象テーブル継承

- サブタイプごとにテーブルを作成する方法
- ER
  ```
  ─ サブタイプテーブル 1
  ─ サブタイプテーブル 2
  ```
- メリット
  - サブタイプに存在しない属性を格納する必要がない
- デメリット
  - 共通属性とサブタイプ特有の属性との切り分けが難しい
  - 共通属性を追加するときに、全てのサブタイプのテーブル定義を修正しなければならない

## 5.5.3 クラステーブル継承

- オブジェクト指向のクラスに見立てて、継承を模倣する方法
- ER
  ```
  - 基底型のテーブル
    ├ サブタイプテーブル 1
    ∟ サブタイプテーブル 2
  ```

## 5.5.4 半構造化データ

- LOB 列 に JSON データなどの形式で属性名と値を格納する方法
- サブタイプの数が多い場合、頻繁に新しい属性を追加する場合に有効
- ER
  ```
  単一テーブル.LOB属性
  ```
- メリット
  - 拡張性が極めて高いこと
- デメリット
  - 制約などが利用できないこと
  - アプリケーション側の負担が大きいこと
- 使い所
  - 柔軟性が重視される場合に最適

## 5.5.5 後処理

- EAV を使わざるおえない場面もある
  - EAV を利用する外部サービスに依存する場合
- EAV のエンティティとしての取り扱い
  - 行の集合として取得すること

# Part6: ポリモーフィック関連

## アンチパターン: 二重目的の外部キーを使用する

- ポリモーフィック関連(Polymorphic Associations)
- プロミスキャス・アソシエーション(Promiscuous Association: 無差別な関連)
- メリット
  - 複数のテーブルを参照できること
- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220930_163941.jpg)

## ポリモーフィック関連を定義する

- 定義方法
  - issue_type 列に、関連先のテーブル名を文字列として格納
  - issue_id 列に、関連先のテーブルに存在するレコード id を格納
  - 外部キー制約は追加しない(RDS の仕様上、外部キー制約は一つしか設定できないため)
- デメリット
  - issue_type に含まれるテーブル名が正しいことを検証できない
  - issue_id のレコードに対する参照整合性制約を定義できない

## データへのメタデータ混入 が諸悪の根源

- アソシエーション先の定義などは RDS の参照整合性制約などを利用して定義すべき
- RDS の仕様上できないことをデータへのメタデータ投入により実現しようとして、データ不整合などが発生してしまう

## アンチパターンの見つけ方

- 「この tagging スキーマは、タグをデータベース内の『あらゆる』リソースと関連づけられるんだ」
  - 無限の柔軟性はありえない
- 「このデータベース設計では、外部キーは宣言できません」
  - RDB の基本機能が利用できないのは危険信号
- 「この entity_type 列は、何のためのもの？」「ああ、それはこの entity_id 列がどのテーブルの値を参照しているのかを示すものなんだ」
  - 外部キーではすべての行で同じテーブルを参照する必要がある
- 備考
  - Rails の ActiveRecord では Polymorphic 関連をサポートしている

## ポリモーフィック関連を用いてもよい場合

- ActiveRecord のような ORM でポリモーフィック関連がサポートされている場合
- フレームワークでサポートされておらず、スクラッチで構築するのは車輪の再発明であるため、素直に外部キー制約を用いた手法でやるべき

## 解決策: 関連(リレーションシップ)を単純化する

### 参照を逆にする

- 「本来あるべき関連が、逆さまになっている」のが諸悪の根源

### 交差テーブルの作成

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220930_172408.jpg)
- メリット
  - issue_type 列が不要になる
  - 参照整合性を担保できる

### 交差点に交通信号を設置する

- 交差テーブルに制約がない状態だと以下の問題が発生
  - 同じ 1:1 の関連レコードが重複できてしまう
  - 1:N や N:N が構築できてしまう
- 対処法
  - 交差テーブルに UNIQUE 制約を定義すること
  - ただし、1:N や N:N は防ぐことができないため、アプリケーション側で対処する必要がある

### 共通の親テーブルの作成

- 資料
  ![](/docs/database_design/sql_antipatterns/images/20220930_174301.jpg)
- 共通の親テーブルとして、基底テーブルを作成して関連させる方法
  - 同じようなエンティティが複数の親テーブルを参照させたいときは、基底テーブルというエンティティを定義できる可能性がある
- メリット
  - 外部キー制約を定義できること

# Part7: マルチカラムアトリビュート(複数列属性)

- ひとつのテーブルに属するべき値が複数あるときにどのように格納するべきか、という問題
- Part7 ではバグを分類するための「タグ付け機能」を例としてあげている

## アンチパターン: 複数の列を定義する

- 複数値の数だけテーブルに属性を定義して、「列」として値を格納する方法
- ER
  ```
  テーブルA
    - tag_1: string
    - tag_2: string
    - tag_3: string
  ```
- 複数値をカンマ区切りで入力するべきでない(ジェイウォークを参照)を考慮した自然な選択のように思える

### 値の検索

- 特定のタグを検索したいときに、すべてのタグ列を検索対象にする必要あり
- 複数タグの AND 条件などのクエリが複雑化
  - ただし、IN 述語で短縮可能

### 値の追加と削除

- タグを更新する場合には、対象行の値を取得してタグの状態をアプリケーション側で確認しなければ安全に更新できない
  - どのタグ列に何の値が入っているのか、どのタグ列が空いているのか不明なため

### 一意性の保証

- 複数列に同じ値が登録できてしまう

### 増加する値の処理

- 必要な列数をあらかじめ予測することが困難
- 後から列数を追加したときのコストが高い
  - 追加するたびにアプリケーションの修正が必要で、かつ、バグの発生リスクあり

## アンチパターンの見つけ方

- 複数割り当て可能な値が存在していて、値の個数に上限が定められている属性は要注意
- よくある発言
  - 「サポートすべきタグの最大数はいくつ？」
    - タグ列をいくつテーブルに定義すべきか悩んでいる可能性あり
  - 「SQL で同時に複数の列を検索する方法は？」
    - 一つの論理的な属性が複数列に格納されている可能性あり
- アンチパターンの共通点
  - 「複数の値を持つ可能性のある属性を格納する」という問題を抱えていること
  - ジェイウォーク
    - N:N
  - マルチカラムアトリビュート
    - 1:n

## アンチパターンを使ってもよい場合

- 論理的に異なる属性であれば利用しても問題ない
  - 例
    - タグ列 1: バグ発見者(User モデル.id)
    - タグ列 2: バグ修正者(User モデル.id)
    - タグ列 3: テスト担当者(User モデル.id)
  - とはいえ、列名にぞれぞれ適切な命名をすべきであって、マルチカラムアトリビュートを実践しようとしているケースとは異なる気がする

## 解決策: 従属テーブルを作成する

- 従属テーブルを作成して外部キー制約を定義して、従属テーブルで「行」として複数の値を格納する方法
- ER
  ```
  テーブルA
    - 従属テーブルA
      - id: integer
      - tag_name: string
  ```
- メリット
  - タグの検索が容易であること
  - 複数タグによる AND 条件での検索が容易であること
  - タグの重複登録を PK 制約で防げること
- 教訓
  - 「同じ意味を持つ値は、一つの列に格納するようにすること」

# Part8: メタデータトリブル(メタデータ大増殖)
