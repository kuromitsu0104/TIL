# 概要

## 本

- Clean Architecture 達人に学ぶソフトウェアの構造と設計

# Part1: イントロダクション

## Chap1: 設計とアーキテクチャ

- 設計とアーキテクチャの両者には何も違いはない
  - 下位レベルの詳細と上位レベルの構造は全体の設計の一部となる
  - それらが連続した構造を作り、システムの形状を定義する。どちらも欠くことはできない

### 目的は？

- **ソフトウェアアーキテクチャの目的は、求められるシステムを構築・保守するために必要な人材を最小限に抑えることである。**
  - 必要な労力が少ない => 優れた設計
  - 必要な労力が多い => 優れていない設計

### ケーススタディ

- エンジニアリング部門の人材が増えるごとにリリースサイクルが伸び悩む

### 崩壊のサイン

- 開発者視点では一生懸命働いているが、リリースするたびに生産性が低下してしまう状態
- 生産性が低下する理由 => 崩壊の対応を続けることで機能の開発がほとんどできないため

### 経営者の視点

- リリースごとに開発者の給与が上昇
- ただし、生産性は低下してリリースサイクルが伸び悩んでしまう

### 何が間違っていたのか？

- イソップの「ウサギとカメ」という物語
  - 「遅くとも着実であれば競争に勝つ」
  - 「競争は短期決戦ではない。強い物が勝つわけではない」
  - 「急げば急ぐほど速度は落ちる」
- 優れた、クリーンな、うまく設計されたコードが**重要である**
- 「あとでクリーンにすればいい。先に市場に出さなければ」
  - => 次の開発が優先され続けて、コードをクリーンにすることに手が回らなくなる
- 崩壊したコードを書くと短期的には速度が上がる => 間違い
  - **崩壊したコードを書くほうがクリーンなコードを書くよりも常に遅い**
  - TDD のほうが全体的に 10%ほど速い
  - 「TDD を使わなかった最速時間よりも、TDD を使った最遅速度のほうが速い」のが真実
- **速く進む方法唯一の方法は、うまく進むことである。**
- 解決策
  - 自ら生み出した崩壊に対して責任を持たせること
- **自信過剰による再設計は、元のプロジェクトと同じように崩壊する**
  - 優れた設計について真剣に向き合うことが、最善の選択肢となる

## Chap2: 2 つの価値のお話

- すべてのソフトウェアシステムは、ステークホルダーに２つの異なる価値を提供する
  - 「振る舞い」と「構造（アーキテクチャ）」
- 開発者は「振る舞い」と「構造」を維持する責任を持つ
  - 片方だけにフォーカスすることが多く、一方が無視されてしまっている

### 振る舞い

- ソフトウェアに「振る舞い」を与えてステークホルダーの要求を満たす

### アーキテクチャ

- ソフトウェアの 2 つ目の価値は「ソフトウェア」という言葉に関連する
  - ソフトウェア =>「ソフト + ウェア」による複合語
  - ウェア => 「プロダクト」を意味する
- ソフトウェア => マシンの振る舞いを簡単に変更する手段になることを目的としたもの
- ハードウェア => マシンの振る舞いを簡単に変更したくないときに呼ばれるもの
- ソフトウェアは簡単に変更可能でなければならない
  - 変更の難易度は、変更の**形状**ではなく、変更の**スコープ**に比例しなければいけない
    - スコープが狭いにも関わらず変更の難易度が高い => ソフトウェアとしては不適合
- 形状について
  - ソフトウェア開発者は「四角い」ベグを「丸い」穴に打ち込まなければいけないような気持ちになることがある
  - アーキテクチャが特定の「形状」を選択していると、新しい機能がその構造に適さない可能性が高くなる
  - => 形状にとらわれないアーキテクチャにしたほうが現実的

### 大きな価値

- システムが動作することが重要なのか。簡単に変更できることのほうが重要なのか
- ビジネスサイドの意見としては「システムが動作することが重要」を優先しがち
  - **これが間違った態度である理由**
    - 完璧に動作するが、変更できないプログラムの場合
      - 要求が変更されると機能しなくなる、修正することも困難
      - いずれプログラムが役に立たなくなり、作り直すことになる（コスト増）
    - 動作しないが、簡単に変更できるプログラムの場合
      - 要求が変更されても修正可能のため動かし続けられる
      - 引き続きプログラムとして役立つことになる
- 変更コストと作り直すコストを比較して、作り直すコストのほうが低いときは、アーキテクチャに問題を抱えている可能性が高い
- 変更のコストがメリットを上回っており、変更が**事実上できなくなっている**システムは存在する

### アイゼンハワーのマトリックス

- ドワイト・D・アイゼンハワー大統領による「重要度と緊急度のマトリックス」
  - | -                     | -                             |
    | --------------------- | ----------------------------- |
    | 重要<br/>緊急         | 重要<br/>緊急ではない         |
    | 重要ではない<br/>緊急 | 重要ではない<br/>緊急ではない |
  - 「私には緊急と重要の 2 種類の問題がある。緊急と重要は違う。重要なことが緊急になるわけではない。」
  - 優先順位をつけると
    1. 緊急かつ重要
    2. 緊急ではないが重要
    3. 緊急だが重要ではない
    4. 緊急でも重要でもない
  - ソフトウェアに当てはめてみると
    - ソフトウェアの 1 つ目の価値（振る舞い）は緊急だが、常に重要とは限らない
    - ソフトウェアの 2 つ目の価値（アーキテクチャ）は重要だが、常に緊急とは限らない
  - ビジネスマネージャーはアーキテクチャの重要性を評価できない、というジレンマがある
    - ソフトウェア開発者には「**機能の緊急性よりもアーキテクチャの重要性を強く主張する責任がある**」

### アーキテクチャの戦い

- **ソフトウェア開発者もステークホルダー**である
  - ソフトウェアに対する責任がある
- アーキテクチャを後回しにすると、システムの開発コストはますます高くなり、システムの一部または全部が変更不能になる

# Part2: 構成要素から始めよ : プログラミングパラダイム

- さまざまなプログラミングの革命
  - 言語の革命
  - プログラミングパラダイムの革命
- パラダイム => プログラミング手法のこと

## Chap3: パラダイムの概要

- 3 つのパラダイム
  - 構造化プログラミング
  - オブジェクト指向プログラミング
  - 関数型プログラミング

### 構造化プログラミング

- **構造化プログラミングは、直接的な制御の移行に規律を課すものである**
  - goto 文の削除

### オブジェクト指向プログラミング

- **オブジェクト指向プログラミングは、間接的な制御の以降に規律を課すものである**
  - 関数ポインタの削除

### 関数型プログラミング

- **関数型プログラミングは、代入に規律を課すものである**
  - 代入の削除

### 考えるべきこと

- それぞれのパラダイムでは、プログラマから能力を削除している
- **何をすべきか**を伝えると言うよりも、**何をすべきでないか**を伝えているものである

### まとめ

- パラダイムの歴史的な教訓とアーキテクチャは「すべて」において関係している
- アーキテクチャの 3 つの関心ごと
  1. コンポーネントの分離
  2. データ管理
  3. 機能

## Chap4: 構造化プログラミング

### 証明

- goto を「うまく」使えば、 if/then/else などの選択や、do/while といった反復の制御構造に対応可能
- あらゆるプログラムは「順次」「選択」「反復」の 3 つの構造で構築できる

### 有害宣言

- GOTO 文の有害性が広く認められるようになる

### 機能分割

### 正式に証明できない

### 救済のための科学

- 科学の理論や法則は、正しいと証明することができない
  - 科学と数学の根本的に異なる点
  - 実証できても数学的に証明することができない
- 反証可能で成立している
  - 真ではないことを証明することで機能している

### テスト

- テストはバグが存在しないことではなく、バグが存在することを示すものである
  - テストによりプログラムが正しくないことを証明できるが、プログラムが正しいことは証明できない

### まとめ

- 機能分割がベストプラクティス
- 反証できる（テストできる）単位でモジュール、コンポーネント、サービスを定義する
- 反証可能なプログラムの単位を構成するために、goto 文に制限をかけたものが構造化プログラミング

## Chap5: オブジェクト指向プログラミング

- OO 言語 = オブジェクト指向言語
- OO 言語は、**カプセル化・継承・ポリモーフィズム**の性質を持つ、という人もいるがそうではない

### カプセル化とは？

- OO 言語登場以前は完璧なカプセル化を実現できていた
- OO 言語登場以降は逆に弱体化した
- OO 言語は強制的なカプセル化をほとんど、あるいは全く持っていない。
  - OO 言語がカプセル化に依存しているとは言えない
  - クラスのメンバーへのアクセスをコントロールすることはできるが、完璧なカプセル化を実現するわけではない

### 継承とは？

- 継承のトリックは OO 言語が登場する前から存在していた
  - OO 言語独自の機能ではない
- OO 言語登場以前の継承のトリックにはいくつか問題があり、便利ではなかった
  - 多重継承が困難
  - トリックの手続きが複雑
- OO 言語登場以降では、トリックの手続きが暗黙的で容易になったこと、多重継承も可能となった
- ただし、これだけでは OO 言語が優れているとはいえない

### ポリモーフィズムとは？

- ポリモーフィズムは OO 言語登場以前から存在する
- ポリモーフィズムは関数へのポインタの応用である
- OO 言語が新しいことを提供しているわけではないが、安全かつ便利にしてくれている
  - 関数へのポインタを意識せずに利用できるようになった（関数ポインタの削除）

### ポリモーフィズムのパワー

- 関数ポインタへの危険性を排除したことにより、プラグインアーキテクチャをどこでも何にでも使うことができる

### 依存関係逆転

- ポリモーフィズム以前の典型的な呼び出しツリーは、main 関数が上位の関数を呼び出し、それが中間レベルの関数を呼び出し、それが解レベルの関数を呼び出す、というもの
  - 制御の流れに従ったものとなる
- **依存関係逆転**
- OO 言語が安全で便利なポリモーフィズムを提供していると言うことは、**ソースコードの依存関係は（たとえどこにあっても）逆転できる**ことを意味する
- ソースコードの依存関係の方向を**絶対的に制御**できる
  - これが OO の提供するパワーである

### まとめ

- OO とは、「ポリモーフィズムを使用することで、システムにあるすべてのソースコードの依存関係を絶対的に制御する能力」である

## Chap6: 関数型プログラミング

### 整数の二乗

- 関数型言語の変数は変化しない

### 不変性とアーキテクチャ

- アーキテクチャの観点で不変性が重要となる理由
  - 競合状態、デッドロック状態、並行更新の問題の原因が、すべて可変変数にあるから
  - 並行処理（複数のスレッドやプロセスを必要とする）アプリケーションでは顕著

### 不変性の分離

- 不変性の妥協点
  - 「可変コンポーネント」と「不変コンポーネント」に分離すること
- トランザクショナルメモリ
  - 変更可能な変数を並行更新や競合状態から保護する方法
- 不変コンポーネントにできるだけ多くの処理を押し込み、可変コンポーネントからできるだけ多くのコードを追い払うべき

### イベントソーシング

- イベントソーシング
  - 状態ではなく取引（トランザクション）を保存するという戦略
  - 状態が必要なときに集計を行なって算出する
  - 集計処理のショートカットとして、毎日 0 時に状態を算出。これに加えて 0 時からの取引を集計すれば最新の状態を算出可能となる
- イベントソーシングを実現したとき、アプリケーションは CRUD ではなく CR だけで動作可能となる
  - つまり、**完全に関数型になる**

### まとめ

- 構造化プログラミングは、直接的な制御の移行に規律を課すものである
- オブジェクト指向プログラミングは、間接的な制御の移行に規律を課すものである
- 関数型プログラミングは、代入に規律を課すものである

# Part3: 設計の原則

- SOLID 原則とは
  - 以下のような性質を持つ中間レベルのソフトウェア構造を作ること
    - 変更に強いこと
    - 理解しやすいこと
    - コンポーネントの基盤として、多くのウェアシステムで利用できること
- モジュールレベルの開発によく使われるもの
- SOLID 原則
  - 単一責任の原則 (SRP: Single Responsibility Principle)
    - 個々のモジュールを変更する理由はたった一つだけになるようにすること
  - オープン・クローズドの原則 (OCP: Open-Closed Principle)
    - 既存コードの変更より、新しいコードの追加によって、システムの振る舞いを変更できるように設計すること
  - リスコフの置換原則 (LSP: Liskov Substitution Principle)
    - 個々のパーツが交換可能となるような規約に従うこと
  - インターフェイス分離の原則 (ISP: Interface Segregation Principle)
    - 使っていないものへの依存を回避すべきという原則
  - 依存関係逆転の原則 (DIP: Dependency Inversion Principle)
    - 上位レベルのクラスが下位レベルのクラスの実装コードに依存するのではなく、下位レベルのクラスを上位レベルのクラスの実装に依存させること

## Chap7: SRP : 単一責任の原則

- SOLID 原則のなかで最も誤解されがち
  - 「どのモジュールもたった一つのことだけを行うべき」
  - ex)
    - 巨大な関数をリファクタリングして、小さな関数に切り分けてそれぞれ一つのことだけを行うようにした
  - 最下位のレベルに対して実施するのはいいが、SOLID 原則の単一責任の原則 (SRP)とは別のものである
- **モジュールを変更する理由はたった一つだけであるべきである。**
  - 「変更する理由」 -> 「ユーザーやステークホルダー」を満足させるための変更
- **モジュールはたったひとりのユーザーやステークホルダーに対して責務を負うべきである。**
  - 実際のところ、ステークホルダーが複数になる場合が多いため、「たったひとりの」ではなく、グループとして扱うことが多い。
  - ステークホルダーのグループ == アクター と呼ぶ
- **モジュールはたったひとつのアクターに対して責務を負うべきである。**
- 「モジュール」は、いくつかの関数やデータをまとめた凝集性のあるものとして考える
- 「凝集性」が、ひとつのアクターに対する責務を負うコードをまとめるフォースとなる

### 症例 1: 想定外の重複

- 複数のアクターが利用するクラス
- ある一つのアクターでの処理を修正したとき
  - => 別のアクターの処理に影響を及ぼす可能性がある
- 複数のアクターにまたがるロジックが存在しており、共通メソッドとして切り出したとき
  - => 想定外のアクターから共有メソッドが呼び出すようになったり、想定外なアクターが共通メソッドを利用していることに気づかず、ロジックを修正して別のアクターの処理に影響を及ぼす可能性がある
- 別々のアクターのコードを一つにまとめてしまったのが問題の原因
- 単一責任の原則 (SRP)は、**アクターの異なるコードは分割するべき**という原則だ

### 症例 2: マージ

- 複数のアクターが利用するクラスで、それぞれのアクターに対するクラスの修正が入ったとき
- コンフリクトが発生する可能性や、コンフリクトが発生せずともロジック修正により別のアクターの処理に影響を及ぼす可能性がある
  - こうした問題を回避するために、**アクターの異なるコードは分割するべき**

### 解決策

- データを保持するクラスは複数のアクターに参照させて、関数だけクラスとして切り出す
  - 弱点
    - それぞれの関数のクラスをインスタンス化して、追跡する必要がある
  - 解決策
    - Facade パターン
    - 実行したい関数を持つクラスのインスタンスを生成して、処理を委譲するためのクラスを作成する

### まとめ

- 単一責任の原則 (SRP)は、関数やクラスに関する原則
- 同じような原則は別のレベルにも存在する
  - コンポーネントレベル: 閉鎖性共通の原則 (CCP)
  - アーキテクチャレベル: アーキテクチャの境界を作るための「変更の軸」

## Chap8: OCP : オープン・クローズドの原則

- ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべきである

### 思考実験

- 財務情報を Web ページに表示するシステムを例として考える
- 単一責任の原則 (SRP)を適用する際は、データフロー図を用いて整理する
  - 責任が複数存在する場合は、責務ごとにクラスを分割
- 変更を取り消すことなく振る舞いを拡張できるようにする方法
  - 処理をクラスに分割して、それぞれのクラスをコンポーネントにまとめる
    - Controller
    - Interactor
    - Database
    - Presenter
    - View
  - コンポーネント間の依存関係は、**すべて一方通行**となる
  - コンポーネント A がコンポーネント B からの変更から保護されるべきならば、コンポーネント B はコンポーネント A に依存するべきである
  - Interactor コンポーネントは依存される側の存在
    - Interactor コンポーネントはビジネスルールを含んでおり、アプリケーションの中でも最上位のレベルとなるため
  - Controller コンポーネントは Presenter コンポーネントに依存される存在
- 「レベル」の概念にもとづいた保護の階層がつくられる
- これが、アーキテクチャレベルにおけるオープン・クローズドの現族 (OCP)である

### 方向の制御

- それぞれのコンポーネント間にはインターフェイスが存在して、上位レベルのコンポーネントはインターフェイスが存在することで下位レベルのコンポーネントの知識が不要となる。
  - 依存関係を逆転させるため（正しい依存関係の方向を聖所するため）にインターフェイスを用意している

### 情報隠蔽

- 推移的な依存関係を排除するためのインターフェイス
- 「ソフトウェアのエンティティは自分が使っていないものに依存すべきではない」

### まとめ

- システムをコンポーネントに分割して、コンポーネントの依存関係を階層構造にする
- 上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないようにする

## Chap9: LSP : リスコフの置換原則

### 継承の使い方の指針

- 派生型に依存せず、派生元の型に置き換えられること

### 正方形・長方形問題

- LSP 違反の代表例
- 派生元と派生先とで、初期化方法やフィールド、メソッドが異なること、上位クラスがそれらを考慮しなくてはならなくなる
  - ex) 上位クラスに if 文を追加して派生元と派生先の型に依存させる
  - これでは、派生元と派生先の置換が不可能となる

### リスコフの置換原則（LSP）とアーキテクチャ

- インターフェイスと実装に関するソフトウェア設計の原則
- プログラムの実装方法に限らず、REST インターフェイスでも同様の考え方を用いることが可能

### リスコフの置換原則（LSP)違反の例

## Chap10: ISP : インターフェイス分離の原則

- 複数のクラスが同一のクラスを参照しており、参照先のクラスの一部の機能だけ利用している状態
- 一部の機能だけ参照しているだけだが、使用していない他の機能にも依存していることになる
- 別のクラスのためだけに参照先のクラスを修正したにも関わらず、Java のような言語だと参照元のクラスを全て再コンパイルしなければならなくなってしまう

### インターフェイス分離の原則（LSP)と言語との関係

- Java のようなコンパイルが必要な言語で発生
- Ruby では発生しない

### インターフェイス分離の原則（LSP)とアーキテクチャとの関係

- 必要としないモジュールに依存することは一般的に有害とされる
- アーキテクチャレベルでも同様であること

### まとめ

- 必要としないお荷物を抱えたものに依存すると、予期せぬトラブルにつながるということ

## Chap11: DIP : 依存関係逆転の原則

- ソースコードの依存関係が（具象ではなく）抽象だけを参照しているもの。それが、最も柔軟なシステムである。
  - Java => Interface のような抽象クラスにだけ依存させる
  - Ruby => 具象モジュールを参照しない
- 具象モジュール: 関数の実装が書かれているモジュールのこと
- 具象モジュールに依存する場合であっても、String クラスのような安定したクラスであれば問題ない
- 変化しやすい具象要素には依存するべきでない

### 安定した抽象

- 抽象インターフェイスは具象クラスよりも安定している
- インターフェイスの変動性をできるだけ抑えること
- 機能改修でもできるだけインターフェイスの変更なしで済ませられるようにする
- 変化しやすい具象への依存を避け、安定した抽象インターフェイスに依存するべき
- コーディングレベルのベストプラクティス
  - 変化しやすい具象クラスを参照しない
    - 代わりに抽象インターフェイスを参照
    - **Abstract Factory パターン**で対応するのが一般的
  - 変化しやすい具象クラスを継承しない
    - 継承が依存関係の一種であること
    - 動的型付け言語では大きな問題はないが、静的型付け言語だと強力な依存関係が生まれてしまう
  - 具象関数をオーバーライドしない
    - 具象関数は依存を要求することが多いため
    - 元の関数を抽象関数にして依存を管理する必要がある
  - 変化しやすい具象を名指しで参照しない

### Factory

- ベストプラクティスに従う場合は、Abstract Factory パターンで依存関係を管理する
- ソースコードの依存性は、具象側から抽象側へと向かわせる
- システムを二つのコンポーネントに分割
  - 抽象コンポーネント
    - すべての上位レベルのビジネスルールを含む
  - 具象コンポーネント
    - ビジネスルールが操作する実装の詳細を含む
- ソースコードの依存性と処理の流れは逆向きになる（依存関係逆転の原則 DIP）

###　具象コンポーネント

- DIP を完全に取り入れることは難しい
- DIP を満たさない具象コンポーネントを少数に絞り込んで分離することはできる

### まとめ

# Part4: コンポーネントの原則

- SOLID 原則: レンガを組み合わせて部屋を作る方法を伝える原則
- コンポーネントの原則: 部屋を組み合わせて建物を作る方法を伝える原則

## Chap12: コンポーネント

- コンポーネント: デプロイの単位のこと
  - Java => .jar
  - Ruby => gem
  - .Net => DLL
- よくできたコンポーネントは常に個別にデプロイできる状態を保っている

### コンポーネントの簡単な歴史

### リロケータビリティ（再配置可能性）

### リンカ

### まとめ

## Chap13: コンポーネントの凝集性

- 再利用・リリース等価の原則（REP）
- 閉鎖性共通の原則（CCP）
- 全再利用の原則（CRP）

### 再利用・リリース等価の原則（REP)

```
再利用の単位とリリースの単位は等価になる
```

- コンポーネントを形成するクラスやモジュールは凝集性のあるグループでなければいけない
- コンポーネントにはリリース番号が付与されており、再利用するコンポーネントの互換性が確認できること
- ひとつのコンポーネントを形成するクラスやモジュールは、**まとめてリリース可能**でなければいけない

### 閉鎖性共通の原則（CCP)

```
同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること。変更の理由やタイミングが異なるクラスは、別のコンポーネントに分けること。
```

- 単一責任の原則（SRP）をコンポーネント向けに言い換えたもの
  - SRP: **クラス**を変更する理由が複数あるべきではない
  - CCP: **コンポーネント**を変更する理由が複数あるべきではない
- 一般的なアプリケーションでは、再利用性よりも保守性の方が重要
- 同じタイミングで変更されることの多いクラスはひとつにまとめておく
- CCP での「閉鎖性」は、オープン・クローズドの原則（OCP）の「クローズド」と同じ意味
- 「変更の種類が似ているクラスをひとつのコンポーネントにまとめる」

#### 単一責任の原則（SRP）との類似点

- CCP は単一責任の原則（SRP）をコンポーネントに適用したもの
  - SRP: 変更の理由が異なるメソッドは別のクラスに分けるという原則
  - CCP: 変更の理由が異なるクラスは別のコンポーネントに分けるという原則

### 全再利用の原則（CRP）

```
コンポーネントのユーザーに対して、実際に使わないものへの依存を強要してはいけない。
```

- 一緒に用いられることが多いクラスやモジュールは同じコンポーネントにまとめてもよいというもの
- 使う側のコンポーネントと使われる側のコンポーネントに依存関係があって密結合しているとき、同じコンポーネントにまとめて再利用するべき
- CCP は「どのクラスをひとまとめにするべきでないか」を伝える原則
  - 密結合していないコンポーネントをひとつにまとめるべきでない

#### インターフェイス分離の原則（ISP）との関係

- CCP はインターフェイス分離の原則（ISP）を一般化したもの
  - ISP: 使っていないメソッドを持つクラスに依存しないようにすること
  - CCP: 使っていないクラスを持つコンポーネントに依存しないようにすること

```
不要なものには依存しないこと。
```

### コンポーネントの凝集性のテンション図

- 再利用・リリース等価の原則（REP）、閉鎖性共通の原則（CCP）、全再利用の原則（CRP）はそれぞれに相反するところがある
  - REP, CCP
    - それぞれが包含関係
    - ひとつのコンポーネントを大きくする方向に働く
  - CRP
    - REP, CCP と相反関係
    - ひとつのコンポーネントを小さくする方法に働く
- 各原則の性質
  - REP: 再利用性のためのグループ化
  - CCP: 保守性のためのグループ化
  - CRP: 不要なリリース作業を減らすための分割

### まとめ

- コンポーネントの凝集性は、開発時の利便性と再利用性のトレードオフ
