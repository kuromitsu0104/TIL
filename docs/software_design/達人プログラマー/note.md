# 概要<!-- omit in toc -->

- 書籍名
  - 達人プログラマー

# 学習目的<!-- omit in toc -->

- [ ] ソフトウェア開発についての新たな観点や知識を身につける

# 学習アウトプット<!-- omit in toc -->

- [ ] 新たな視点や勘所、キーワードについて整理し、読書メモとしてリポジトリに残す
- [ ] これまでの開発経験と比較して、自然に体現できている部分と、改善すべき部分を言語化する([技術記事化](https://github.com/kuroweb/zenn/blob/master/articles/the-pragmatic-programmer.md))

# 目次<!-- omit in toc -->

- [第1章　達人の哲学](#第1章達人の哲学)
  - [1 あなたの人生](#1-あなたの人生)
  - [2 猫がソースコードを食べちゃった](#2-猫がソースコードを食べちゃった)
  - [3 ソフトウェアのエントロピー](#3-ソフトウェアのエントロピー)
  - [4 石のスープとゆでガエル](#4-石のスープとゆでガエル)
  - [5 十分によいソフトウェア](#5-十分によいソフトウェア)
  - [6 あなたの知識ポートフォリオ](#6-あなたの知識ポートフォリオ)
  - [7 伝達しよう！](#7-伝達しよう)
- [第2章　達人のアプローチ](#第2章達人のアプローチ)
  - [8 よい設計の本質](#8-よい設計の本質)
  - [9 DRY 原則 - 二重化の過ち](#9-dry-原則---二重化の過ち)
  - [10 直交性](#10-直交性)
  - [11 可逆性](#11-可逆性)
  - [12 曳光弾](#12-曳光弾)
  - [13 プロトタイプとポストイット](#13-プロトタイプとポストイット)
  - [14 専用の言語](#14-専用の言語)
  - [15 見積もり](#15-見積もり)
- [第3章　基本的なツール](#第3章基本的なツール)
  - [16 プレインテキストの威力](#16-プレインテキストの威力)
  - [17 貝殻（シェル）遊び](#17-貝殻シェル遊び)
  - [18 パワーエディット](#18-パワーエディット)
  - [19 バージョン管理](#19-バージョン管理)
  - [20 デバッグ](#20-デバッグ)
  - [21 テキスト操作言語](#21-テキスト操作言語)
  - [22 エンジニアリング日誌](#22-エンジニアリング日誌)
- [第4章　妄想の達人](#第4章妄想の達人)
  - [23 契約による設計（DbC）](#23-契約による設計dbc)
  - [24 死んだプログラムは嘘をつかない](#24-死んだプログラムは嘘をつかない)
  - [25 表明を用いたプログラミング](#25-表明を用いたプログラミング)
  - [26 リソースのバランス方法](#26-リソースのバランス方法)
  - [27 ヘッドライトを追い越そうとしない](#27-ヘッドライトを追い越そうとしない)
- [第5章　柳に雪折れ無し](#第5章柳に雪折れ無し)
  - [28 分離](#28-分離)
  - [29 実世界を扱う](#29-実世界を扱う)
  - [30 変換のプログラミング](#30-変換のプログラミング)
  - [31 インヘリタンス（相続）税](#31-インヘリタンス相続税)
  - [32 設定](#32-設定)
- [第6章　並行性](#第6章並行性)
  - [33 時間的な結合を破壊する](#33-時間的な結合を破壊する)
  - [34 共有状態は間違った状態](#34-共有状態は間違った状態)
  - [35 アクターとプロセス](#35-アクターとプロセス)
  - [36 ホワイトボード](#36-ホワイトボード)
- [第7章　コーディング段階](#第7章コーディング段階)
  - [37 爬虫類脳からの声に耳を傾ける](#37-爬虫類脳からの声に耳を傾ける)
  - [38 偶発的プログラミング](#38-偶発的プログラミング)
  - [39 アルゴリズムのスピード](#39-アルゴリズムのスピード)
  - [40 リファクタリング](#40-リファクタリング)
  - [41 コードのためのテスト](#41-コードのためのテスト)
  - [42 プロパティーベースのテスティング](#42-プロパティーベースのテスティング)
  - [43 実世界の外敵から身を守る](#43-実世界の外敵から身を守る)
  - [44 ものの名前](#44-ものの名前)
- [第8章　プロジェクトを始める前に](#第8章プロジェクトを始める前に)
  - [45 要求の落とし穴](#45-要求の落とし穴)
  - [46 不可能なパズルを解決する](#46-不可能なパズルを解決する)
  - [47 共に働く](#47-共に働く)
  - [48 アジリティーの本質](#48-アジリティーの本質)
- [第9章　達人のプロジェクト](#第9章達人のプロジェクト)
  - [49 達人のチーム](#49-達人のチーム)
  - [50 ココナツでは解決できない](#50-ココナツでは解決できない)
  - [51 達人のスターターキット](#51-達人のスターターキット)
  - [52 ユーザーを喜ばせる](#52-ユーザーを喜ばせる)
  - [53 自負と偏見](#53-自負と偏見)

# 第1章　達人の哲学

## 1 あなたの人生

## 2 猫がソースコードを食べちゃった

- チームにおける信頼関係が大切
- ベストを尽くすのは当然
- 責任を負う場合は、失敗（判断ミスなど）に対して責任を持つべき
- 言い訳よりも対策を考えて提案する
- 要求することを恐れない

## 3 ソフトウェアのエントロピー

- エントロピー増大の法則
  - 割れ窓理論と同じで、部分的に壊れたままにしていると、アプリケーション全体の品質に影響を与える
  - 品質に拘ることを諦めてしまう
- 割れ窓は放置してはならない
  - 実体験
    - ジュニアクラスのエンジニアが割れ窓をベストプラクティスとして理解し、横展開するケースがあった
    - 割れ窓がそのままだと健全なコード実装に向けたモチベーションが削がれる
  - せめて、コメントを残すなどしてダメージを減らせるように工夫すべき
- 割れ窓を直すときに巻き込み事故を発生させない
  - プログラム全体を俯瞰する

## 4 石のスープとゆでガエル

- カエルの問題
  - カエルを入れた鍋でゆっくり加熱したときに、カエルが気付かないまま茹で上がってしまうこと
- 気づかないうちにプログラムが崩壊してしまうことに対する戒め
  - カエルにならないためには、アプリケーション全体を俯瞰する視点が求められる

## 5 十分によいソフトウェア

- 十分に良い（good enough）なソフトウェアを書くようにすればよい
- 今日の素晴らしいソフトウェアは、明日の完璧なソフトウェアよりも好まれる
- 完璧なプログラムは存在しない

## 6 あなたの知識ポートフォリオ

- 知識と経験は、有効期限付きの資産である
- 知識のポートフォリオ
  - 定期的に投資する
  - 多様化する
  - リスクを管理する
  - 安値で買い、高値で売る
  - 見直しと再配分をする
- 具体的なアプローチ
  - 毎年少なくとも言語を1つ学習する
  - 月に1冊のペースで技術書を読む
  - 技術書以外の書籍を読む
  - 講習を受講する
  - 近場のユーザーグループに参加する
  - 異なった環境に慣れ親しんでみる
  - 最先端にとどまり続ける

## 7 伝達しよう！

- 素晴らしいアイデアでも他人に伝えられなければ無意味である
- 聞き手に伝わることがゴール
- 聞き手の要求を知る
- 言いたいことを言語化する
- 適切なタイミングであること
- 見栄えを良くする
  - プレーンテキストよりもMarkdown
  - PowerPointよりもFigma
- 話を聞いてもらいたいなら、自分自身も聞き手にならなければならない
- ドキュメントを作成する
  - 資料を作成する
  - ソースコードにコメントを残す（目的・ゴールのみ記述）

# 第2章　達人のアプローチ

## 8 よい設計の本質

- よい設計は悪い設計よりも変更しやすい
- ETC原則（Easier To Change）
  - 変更容易性（責務を単一化するなど）
- ETC原則はルールではなく価値の基準である
- あらゆる設計原則はETC原則の派生（特殊化）したもの
- 手がかりがないときは、「簡単に変更できる」方針で設計する

## 9 DRY 原則 - 二重化の過ち

- プログラマは常にメンテナンスモードであるべき
- メンテナンスモード
  - ビジネスロジックの修正、知識の再編成、再表現などに意識を向けること
- 知識の二重化（重複）を排除するためにDRY原則に従う
- DRY原則
  - Don't Repeat Yourself.
  - 繰り返しを避けること
- DRY原則の注意点
  - コードの繰り返しを避けることだけが目的ではない
  - ビジネスにおける知識の繰り返し（重複）を避けることが目的である
  - たまたまソースコードが似ている箇所で、不適切な共通化をやりがち
- データ構造を露出させたい場合は、アクセサ関数でのみ許可する
  - 統一アクセス原則に関連する考え方
- 再利用しやすいようにすること（再利用しやすければ重複が発生しづらい）
  - ドキュメントを整備する
  - 他の開発者とコミュニケーションを取る

## 10 直交性

- 直交性
  - 直角に交わる2つの線分はそれぞれ「独立している」
  - 一方を移動してももう一方に影響を与えない
  - ≒ 独立性, 結合度が低い
  - ex: AとBは直交している ≒ AとBは疎結合である
- 直交したシステムでは、それぞれのコンポーネントの凝集度が高い
- 直交することの利点
  - 変更や制御が容易
  - 生産性向上（開発期間・テスト期間の短縮に伴い）
  - コンポーネントの再利用を促進する
  - テストが簡単
- 直交性を維持するためのテクニック
  - 結合度を最小化する
    - デメテルの法則
  - グローバル変数を避ける
    - Singletonパターン
  - 類似機能を避ける
    - Strategyパターン
- ユニットテストは直交性を検証できる良い機会となる
- 直交性とDRY原則は密接に関係する
  - DRY原則：重複を最小限にする
  - 直交性：依存関係を最小限にする

## 11 可逆性

- 重大な決定は簡単に元に戻せないことが多い
- 柔軟性のあるソフトウェアを生み出すテクニック
  - DRY原則
  - 分離
  - 外部設定
- 最初からベストな決定をできるとは限らない
- 最終決定などというものは存在しない
- 詳細を抽象レイヤーで隠蔽し、変更を容易にすること

## 12 曳光弾

- 曳光弾
  - 弾道を光の筋で目視できるもの
- 目標が曖昧な開発でも曳光弾の考え方が役立つ
  - フィードバックが必要な領域に絞って開発を行う
  - 完璧な動作である必要はない
  - ドキュメントやテストを残しておき、軌道修正を容易にする
- 曳光弾のメリット
  - 早いうちからユーザーにものを提示できる
  - 統合テストを実施できるようになる
  - デモ可能なものを手にできる
  - 進捗が明確になる
- 曳光弾は外れる可能性がある
- 曳光弾とプロトタイピングは異なる
  - プロトタイピング：使い捨てのコードを生成する
  - 曳光弾：最小限度で完全なもの（部品）を生成する

## 13 プロトタイプとポストイット

- プログラムのプロトタイプは、コーディング以外にも付箋（ポストイット）を使った方法がある
- 詳細を考慮するべきケースは曳光弾、詳細を考慮する必要のないケースはプロトタイプが適切
- プロトタイプで調査できること
  - アーキテクチャ
  - 既存システムに追加する新機能
  - 外部データの構造や内容
  - サードパーティのツールやコンポーネント
  - パフォーマンス
  - UIの設計
- プロトタイピングの目的の本質は学習の経験であり、生成したコードではない。学んだ教訓に価値がある。
- プロトタイプの使い方
  - 正確性
    - ダミーデータでも問題なし
  - 完全性
    - 機能を限定しても良い
  - 堅牢性
    - エラーチェックは不完全でもよい
    - エラー画面が出てもよい
  - スタイル
    - ソースコードにコメントを残さなくてもよい
    - 学んだ知見はドキュメントにすること
- アーキテクチャのプロトタイピングの観点
  - 主要コンポーネントの責務が適切か
  - 主要コンポーネント間の協調の定義が適切か
  - 結合度が最小化されているのか
  - 重複が発生しそうな箇所があるのか
  - インターフェース定義や成約が妥当か
  - データへのアクセス方法が適切か
- プロトタイピングの誤用
  - 使い捨てのコードであることを理解できていないこと
  - プロトタイピングをベースにプロジェクトを進めること（ありえない）

## 14 専用の言語

## 15 見積もり

- 使用する単位によって、聞き手の印象が異なる
  - 130日: ある程度正確な見積もりである印象を与える
  - 6ヶ月: 5 ~ 7ヶ月？といった曖昧な印象を与える
- おすすめの単位
  | 期間 | 単位 |
  | --- | --- |
  | 1 ~ 15日 | 日 |
  | 3 ~ 8週 | 週 |
  | 8 ~ 20週 | 月 |
  | 20週超 | どの単位を使うべきかよく検討する |
- 見積もりの精度を上げる秘訣
  - 過去の似たようなプロジェクトを参考にする
  - 要望を正確に理解する
  - 大まかなシステムのモデリングを行う
    - どの程度までモデリングするのかは経験則で判断するしかない
  - モデルをコンポーネントに分割する
    - SLI/SLOなど、見積もりに影響を与えるパラメータを書き出す（値まで定義しなくてよい）
  - パラメータに値を与える
    - パラメータを定義してモデルを俯瞰する
    - パフォーマンスなども検討する
  - 自身の見積もり能力を過信しないこと
- インクリメンタルな開発を繰り返すことで解決する(アジャイル開発に近い？)
  - 要求の洗い出しを行う
  - リスクを分析する(リスクの高い項目を優先する)
  - 設計と実装、統合を行う
  - ユーザーとともに検証する
- 見積もりを要求された場合は、「後ほどお持ちします」で対応する
  - すぐに回答できる内容に精度はない
  - しかし、見積もりを聞いた相手は内容を忘れることはない（いい加減な見積もりを正しい情報として捉えがち）

# 第3章　基本的なツール

- 道具は自身の能力を増幅する
- 道具を増やすことを心がける
- マーフィーの法則
  - 「失敗する可能性のあるものは、必ず失敗する」

## 16 プレインテキストの威力

- プレインテキストの強いところ
  - 陳腐化しない
    - 別形式に切り替わる可能性が限りなく低い
  - 活用しやすい
    - 正規表現やスクリプトなどでデータ抽出するなど

## 17 貝殻（シェル）遊び

- GUIではできないことをCLIではできる(大体なんでもできる)
- 自分専用のシェルを作り上げる
  - プロンプト設定
    - 色味や表示内容をカスタムする
  - エイリアスやシェル関数の定義
    - 頻出コマンドを短縮したり、再利用できるようにする
    - 危険なコマンドを実行できないようにする

## 18 パワーエディット

- エディタに熟達することのメリット
  - 繰り返し動作を効率化することで時間短縮できる（おまけ程度のメリット）
  - 本当に考えないといけないことに思考リソースを割けるようになる（余計なことを考えなくてよい）
- 熟達までの一例
  - テキストを編集するときに、文字や単語、行、段落で移動や選択ができること
  - コードを編集するときに、区切り文字や関数、モジュール単位で移動できること
  - インデントを付け直せること
  - 変更のアンドゥとリドゥができること
  - エディタのウィンドウ分割と、ウィンドウ間の移動ができること
  - 特定の行番号に移動できること
  - 選択した範囲の行を並び替えられること
  - 文字列と正規表現による検索ができること
  - 範囲検索やマッチしたパターンに基づいてカーソルを複数生成して、まとめて編集できること
- 熟達のコツ
  - 繰り返し作業を効率化することを心がけること
  - エディタの拡張機能について調べること

## 19 バージョン管理

- あらゆるもので常にVCS(バージョン管理システム)を利用すること
- PC設定などもgit管理しておくと移行が簡単
  - dotfilesのようなリポジトリですべて管理する
    - .ファイル群
    - エディタの設定
    - Homebrewのパッケージ

## 20 デバッグ

- デバッグの目的
  - 非難するのではなく、問題を修復すること
  - 誰がミスしたのかは関係ない。自分事として考えるべき
- デバッグの心構え
  - 「パニクるな」
  - 「そんなことはありえない」は考え方として早く捨てるべきで、「実際におこったのだ」というスタンスにいち早く切り替えなければならない
- デバッグの順序
  1. 正確な情報を収集すること
  2. 正確な情報を元に厳格なテストを行い、バグを再現すること
- コード修正前にテストを失敗させること
- OSやサードパーティ製のライブラリは、基本的には悪くないケースが多い（アプリケーション側に問題があるスタンスで取り組む）

## 21 テキスト操作言語

## 22 エンジニアリング日誌

- 記録は記憶よりも確実
- 記録する仕組みを構築する

# 第4章　妄想の達人

- 完璧なソフトウェアを作ることはできない
  - 理由：そもそも、完璧なソフトウェアなど存在しないため
- 防衛的なコーディングが求められる
- 自分自身も含めて信頼するべきでない（完璧なコーディングができない前提で開発するべき）
- 防衛手段
  - 契約による設計（DbC）
  - 死んだプログラムは嘘をつかない
  - 表明を用いたプログラミング
  - リソースのバランス方法
  - ヘッドライトを追い越そうとしない

## 23 契約による設計（DbC）

- 契約とは
  - 当事者間にある権利と責務を定義するもの
  - 履行しなかった場合の取り決めも記載する
- 契約による設計（DbC）
  - DbCの条件
    - 以下のいずれかの条件を満たさないときに、例外のスローやプログラムの終了などの結果を引き起こす
    - 前提条件
      - 呼び出す前に満たしておくべき条件
      - 条件に違反する場合は呼び出してはいけない
      - 適切なデータを引き渡すのは呼び出し側の責任
    - 事後条件
      - 呼び出し後に保証する内容
      - 永久ループは許可しない
    - クラス不変表明

      - クラスやオブジェクトのインスタンスが常に特定の条件を満たすことを表明すること
      - 例：矩形の幅（width）と高さ（height）を保持し、不変条件として幅と高さが正の値であることを要求する

        ```ruby
        class Rectangle
          attr_reader :width, :height

          def initialize(width, height)
            @width = width
            @height = height
            validate_invariants
          end

          def set_dimensions(width, height)
            @width = width
            @height = height
            validate_invariants
          end

          private

          def validate_invariants
            raise 'Width must be positive' if @width <= 0
            raise 'Height must be positive' if @height <= 0
          end
        end

        # 以下はサンプルの実行例です

        # 正常な矩形のインスタンスを作成
        rectangle = Rectangle.new(5, 10)
        puts "Width: #{rectangle.width}, Height: #{rectangle.height}" #=> Width: 5, Height: 10

        # 不正な値を設定しようとすると例外が発生する
        begin
          rectangle.set_dimensions(-1, 10)
        rescue => e
          puts e.message #=> Width must be positive
        end

        # 不正な値を設定しようとすると例外が発生する
        begin
          rectangle.set_dimensions(5, 0)
        rescue => e
          puts e.message #=> Height must be positive
        end
        ```
    - 条件を厳格にすることで考慮すべき条件が絞られ、少ないコードで対処できるようになる

## 24 死んだプログラムは嘘をつかない

## 25 表明を用いたプログラミング

## 26 リソースのバランス方法

## 27 ヘッドライトを追い越そうとしない

# 第5章　柳に雪折れ無し

## 28 分離

## 29 実世界を扱う

## 30 変換のプログラミング

## 31 インヘリタンス（相続）税

## 32 設定

# 第6章　並行性

## 33 時間的な結合を破壊する

## 34 共有状態は間違った状態

## 35 アクターとプロセス

## 36 ホワイトボード

# 第7章　コーディング段階

## 37 爬虫類脳からの声に耳を傾ける

## 38 偶発的プログラミング

## 39 アルゴリズムのスピード

## 40 リファクタリング

## 41 コードのためのテスト

## 42 プロパティーベースのテスティング

## 43 実世界の外敵から身を守る

## 44 ものの名前

# 第8章　プロジェクトを始める前に

## 45 要求の落とし穴

## 46 不可能なパズルを解決する

## 47 共に働く

## 48 アジリティーの本質

# 第9章　達人のプロジェクト

## 49 達人のチーム

## 50 ココナツでは解決できない

## 51 達人のスターターキット

## 52 ユーザーを喜ばせる

## 53 自負と偏見
