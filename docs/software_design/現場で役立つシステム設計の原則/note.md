# 概要<!-- omit in toc -->

- 書籍名
  - 現場で役立つシステム設計の原則

# 目次<!-- omit in toc -->

- [Chap1: 小さくまとめてわかりやすくする](#chap1-小さくまとめてわかりやすくする)
  - [なぜソフトウェアの変更は大変なのか](#なぜソフトウェアの変更は大変なのか)
    - [ソフトウェアの変更に立ち向かう](#ソフトウェアの変更に立ち向かう)
    - [変更が大変なプログラムの特徴](#変更が大変なプログラムの特徴)
    - [変更するたびに変更が大変になる](#変更するたびに変更が大変になる)
  - [プログラムの変更が楽になる書き方](#プログラムの変更が楽になる書き方)
    - [わかりやすい名前を使う](#わかりやすい名前を使う)
    - [長いメソッドは「段落」に分けて読みやすくする](#長いメソッドは段落に分けて読みやすくする)
    - [目的ごとに変数を用意する](#目的ごとに変数を用意する)
    - [メソッドとして独立させる](#メソッドとして独立させる)
    - [異なるクラスの重複したコードをなくす](#異なるクラスの重複したコードをなくす)
    - [狭い関心事に特化したクラスにする](#狭い関心事に特化したクラスにする)
    - [メソッドは短く、クラスは小さく](#メソッドは短くクラスは小さく)
  - [小さなクラスでわかりやすく安全に](#小さなクラスでわかりやすく安全に)
    - [データとロジック](#データとロジック)
    - [基本データ型の落とし穴](#基本データ型の落とし穴)
    - [値の範囲を制限してプログラムをわかりやすく安全にする](#値の範囲を制限してプログラムをわかりやすく安全にする)
    - [「値」を扱うための専用のクラスを作る](#値を扱うための専用のクラスを作る)
    - [値オブジェクトは「不変」にする](#値オブジェクトは不変にする)
    - [「型」を使ってコードをわかりやすく安全にする](#型を使ってコードをわかりやすく安全にする)
  - [複雑さを閉じ込める](#複雑さを閉じ込める)
    - [配列やコレクションはコードを複雑にする](#配列やコレクションはコードを複雑にする)
    - [コレクション型を扱うコードの整理](#コレクション型を扱うコードの整理)
    - [コレクション型を扱うロジックを専用クラスに閉じ込める](#コレクション型を扱うロジックを専用クラスに閉じ込める)
    - [コレクションオブジェクトを安定させる](#コレクションオブジェクトを安定させる)
    - [コレクションオブジェクトは業務の関心事](#コレクションオブジェクトは業務の関心事)
- [Chap2:場合分けのロジックを整理する](#chap2場合分けのロジックを整理する)
  - [プログラムを複雑にする「場合分け」のコード](#プログラムを複雑にする場合分けのコード)
    - [区分や種別がコードを複雑にする](#区分や種別がコードを複雑にする)
    - [判断や処理のロジックをメソッドに独立させる](#判断や処理のロジックをメソッドに独立させる)
    - [else 句をなくすと条件分岐が単純になる](#else-句をなくすと条件分岐が単純になる)
    - [複文は単文に分ける](#複文は単文に分ける)
    - [区分ごとのロジックを別クラスに分ける](#区分ごとのロジックを別クラスに分ける)
    - [区分ごとのクラスを同じ「型」として扱う](#区分ごとのクラスを同じ型として扱う)
    - [区分ごとのクラスのインスタンスを生成する](#区分ごとのクラスのインスタンスを生成する)
    - [Java の列挙型を使えばもっとかんたん](#java-の列挙型を使えばもっとかんたん)
    - [区分ごとの業務ロジックを区分オブジェクトで分析し整理する](#区分ごとの業務ロジックを区分オブジェクトで分析し整理する)
    - [状態の遷移ルールをわかりやすく記述する](#状態の遷移ルールをわかりやすく記述する)
- [Chap3: 業務ロジックをわかりやすく整理する](#chap3-業務ロジックをわかりやすく整理する)
  - [データとロジックを別のクラスに分けることがわりにくさを生む](#データとロジックを別のクラスに分けることがわりにくさを生む)
    - [業務アプリケーションのコードが見通しが悪くなる原因](#業務アプリケーションのコードが見通しが悪くなる原因)
    - [データクラスを使うと同じロジックがあちこちに重複する](#データクラスを使うと同じロジックがあちこちに重複する)
    - [データクラスを使うと業務ロジックの見通しが悪くなる](#データクラスを使うと業務ロジックの見通しが悪くなる)
    - [共通機能ライブラリが失敗する理由](#共通機能ライブラリが失敗する理由)
    - [業務ロジックをわかりやすく整理する基本のアプローチ](#業務ロジックをわかりやすく整理する基本のアプローチ)
  - [データとロジックを一体にして業務ロジックを整理する](#データとロジックを一体にして業務ロジックを整理する)
    - [業務ロジックを重複させないためにはどう設計すればよいか](#業務ロジックを重複させないためにはどう設計すればよいか)
    - [メソッドをロジックの置き場にする](#メソッドをロジックの置き場にする)
    - [業務ロジックをデータを持つクラスに移動する](#業務ロジックをデータを持つクラスに移動する)
    - [使う側のクラスに業務ロジックを書き始めたら設計を見直す](#使う側のクラスに業務ロジックを書き始めたら設計を見直す)
    - [メソッドを短く書くとロジックの移動がやりやすくなる](#メソッドを短く書くとロジックの移動がやりやすくなる)
    - [メソッドは必ずインスタンス変数を使う](#メソッドは必ずインスタンス変数を使う)
    - [クラスが肥大化したら小さく分ける](#クラスが肥大化したら小さく分ける)
    - [パッケージを使ってクラスを整理する](#パッケージを使ってクラスを整理する)
  - [三層の感心事と業務ロジックの分離を徹底する](#三層の感心事と業務ロジックの分離を徹底する)
    - [業務ロジックを小さなオブジェクトに分けて記述する](#業務ロジックを小さなオブジェクトに分けて記述する)
    - [業務ロジックを全体を俯瞰して整理する](#業務ロジックを全体を俯瞰して整理する)
    - [三層＋ドメインモデルで関心事をわかりやすく分離する](#三層ドメインモデルで関心事をわかりやすく分離する)
- [Chap4: ドメインモデルの考え方で設計する](#chap4-ドメインモデルの考え方で設計する)
  - [ドメインモデルの考え方を理解する](#ドメインモデルの考え方を理解する)
    - [ドメインモデルで設計すると何がよいのか](#ドメインモデルで設計すると何がよいのか)
    - [ドメインモデルの設計は難しいのか](#ドメインモデルの設計は難しいのか)
    - [利用者の関心事とプログラミング単位を一致させる](#利用者の関心事とプログラミング単位を一致させる)
    - [分析クラスと設計クラスを一致させる](#分析クラスと設計クラスを一致させる)
    - [業務に使っている用語をクラス名にする](#業務に使っている用語をクラス名にする)
    - [データモデルではなくオブジェクトモデル](#データモデルではなくオブジェクトモデル)
    - [ドメインモデルとデータモデルは何が違うのか](#ドメインモデルとデータモデルは何が違うのか)
    - [なぜドメインモデルだと複雑な業務ロジックを整理しやすいのか](#なぜドメインモデルだと複雑な業務ロジックを整理しやすいのか)
  - [ドメインモデルをどうやって作っていくか](#ドメインモデルをどうやって作っていくか)
    - [部分を作りながら全体を組み立てていく](#部分を作りながら全体を組み立てていく)
    - [部分を作りながら全体を組み立てていく](#部分を作りながら全体を組み立てていく-1)
    - [全体を部分を行ったり来たりしながら作っていく](#全体を部分を行ったり来たりしながら作っていく)
    - [重要な部分から作っていく](#重要な部分から作っていく)
    - [独立した部品を組み合わせて機能を実現する](#独立した部品を組み合わせて機能を実現する)
    - [ドメインオブジェクトの機能を一部として設計しない](#ドメインオブジェクトの機能を一部として設計しない)
  - [ドメインオブジェクトの見つけ方](#ドメインオブジェクトの見つけ方)
    - [重要な関心事や関係性に注目する](#重要な関心事や関係性に注目する)
    - [業務の関心事を分類してみる](#業務の関心事を分類してみる)
    - [業務の関心事を分離してみる](#業務の関心事を分離してみる)
    - [コトに注目すると全体の関係を整理しやすい](#コトに注目すると全体の関係を整理しやすい)
    - [コトは業務ルールの宝庫](#コトは業務ルールの宝庫)
    - [何でも約束してよいわけではない](#何でも約束してよいわけではない)
    - [期待されるコト、期待されていないコト](#期待されるコト期待されていないコト)
      - [実行されなかったことの検知と対応](#実行されなかったことの検知と対応)
      - [取り決めのないときの取り決め](#取り決めのないときの取り決め)
    - [業務ルールの記述　〜手続き型とオブジェクト指向の違い](#業務ルールの記述手続き型とオブジェクト指向の違い)
      - [業務ルールの追加や変更への対応](#業務ルールの追加や変更への対応)
  - [業務の関心事の基本パターンを覚えておく](#業務の関心事の基本パターンを覚えておく)
    - [ドメインモデルで開発してもトランザクションスクリプトになりがち](#ドメインモデルで開発してもトランザクションスクリプトになりがち)
    - [業務ルールを記述するドメインオブジェクトの基本パターン](#業務ルールを記述するドメインオブジェクトの基本パターン)
      - [口座(Account)パターン](#口座accountパターン)
      - [期日(DueDate)パターン](#期日duedateパターン)
      - [方針(Policy)パターン](#方針policyパターン)
  - [ドメインオブジェクトの設計を段階的に改善する](#ドメインオブジェクトの設計を段階的に改善する)
    - [組み合わせて確認しながら改良する](#組み合わせて確認しながら改良する)
      - [クラス名やメソッド名の変更](#クラス名やメソッド名の変更)
      - [ロジックの移動](#ロジックの移動)
      - [取りまとめ役のクラスを導入](#取りまとめ役のクラスを導入)
    - [業務の言葉とコードを一致させると変更が楽になる](#業務の言葉とコードを一致させると変更が楽になる)
    - [業務を学びながらドメインモデルを成長させていく](#業務を学びながらドメインモデルを成長させていく)
  - [業務の理解がドメインモデルを洗練させる](#業務の理解がドメインモデルを洗練させる)
    - [業務知識を取捨選択し、重要な関心事に注力して学ぶ](#業務知識を取捨選択し重要な関心事に注力して学ぶ)
    - [業務知識の暗黙知を引き出す](#業務知識の暗黙知を引き出す)
    - [言葉をキャッチする](#言葉をキャッチする)
    - [重要な言葉を見極めながらそれをドメインモデルに反映していく](#重要な言葉を見極めながらそれをドメインモデルに反映していく)
    - [形式的な資料はかえって危険](#形式的な資料はかえって危険)
    - [言葉のあいまいさを具体的にする工夫](#言葉のあいまいさを具体的にする工夫)
    - [基本語彙を増やす努力](#基本語彙を増やす努力)
    - [繰り返しながらしだいに知識を広げていく](#繰り返しながらしだいに知識を広げていく)
    - [改善を続けながらドメインモデルを成長させる](#改善を続けながらドメインモデルを成長させる)

# Chap1: 小さくまとめてわかりやすくする

## なぜソフトウェアの変更は大変なのか

### ソフトウェアの変更に立ち向かう

- 修正や拡張が楽で安全になるコードを生み出すのが設計
- クラス図や仕様書が必要であるわけではない
- ソースコードを整理整頓して、どこに何が書いてあるのかわかりやすくするのが設計
- プログラムの修正工数に大きく影響があるのが設計

### 変更が大変なプログラムの特徴

- 特徴一覧
  - メソッドが長い
  - クラスが大きい
  - 引数が多い
- 長いメソッド
  - 理解することが難しくバグが混入しやすい
- 大きなクラス
  - 関心ごとを詰め込みすぎている
- 引数が多いメソッド
  - 引数の関係の理解に時間がかかる
  - 処理が肥大化しやすい

### 変更するたびに変更が大変になる

- 元々はシンプルな実装であったが、小さな変更が積み重なり複雑化していく

## プログラムの変更が楽になる書き方

### わかりやすい名前を使う

- 意味の伝わらない省略形を使用しないこと

### 長いメソッドは「段落」に分けて読みやすくする

- 空白行でまとまりをつくる

  ```ruby
  price = quantity * unit_price

  price += 500 if price < 3000

  price = price * tax_rate
  ```

### 目的ごとに変数を用意する

- 同じ変数を使い回すことで可読性が落ちている
- 「説明用の変数の導入」と呼ばれる手法を用いて改善

  ```ruby
  base_price = quantity * unit_price

  shipping_cost = 0
  shipping_cost = 500 if base_price < 3000

  item_price = (base_price + shipping_cost) * tax_rate
  ```

- 同じ変数に代入し続ける方法は「破壊的代入」と呼ばれ、プログラム変更時の副作用によるバグが発生しやすい

### メソッドとして独立させる

- メソッド化することにより、変更の影響範囲をメソッド内に閉じ込めることができる

  ```ruby
  def shipping_cost(base_price)
  	return 500 if base_price < 3000

  	0
  end
  ```

- 「メソッドの抽出」と呼ばれる手法
  - メイン処理がシンプルになり可読性が向上
  - メソッド名からコードの意図が理解しやすい
  - メソッド内に変更の影響を閉じ込めやすくなる

### 異なるクラスの重複したコードをなくす

- 手順
  - 手順 1.
    - 重複コードでメソッドの抽出を行う
  - 手順 2. 異なるクラス間に参照関係がある場合
    - 参照先にメソッドを実装して、参照しているクラスから参照先のメソッドを呼び出す
  - 手順 2’. 異なるクラス間に参照関係がない場合
    - 共通メソッドの置き場所として新たにクラスを作成してメソッドを実装する
- クラスの置き場所については、ビジネスルールに基づく共通処理であるか、プログラムの都合上の共通処理であるのか、などに基づいてスコープを限定できる場所に配置

### 狭い関心事に特化したクラスにする

- 「送料クラス」では「送料」だけにする
- 「割引」などが発生する場合は、「割引」という関心ごとのクラスを新たに作成する
- 関心事に対応するクラスを「ドメインオブジェクト」と呼ぶ
  - 業務用ごと対応するドメインオブジェクトを用意することが OOP らしいアプローチである

### メソッドは短く、クラスは小さく

- メソッド名とクラス名を、業務の関心事、業務の用語と一致させることで、どこに何が記述されているのかわかりやすくする

## 小さなクラスでわかりやすく安全に

### データとロジック

- 業務アプリケーションの基本データ型
  - 数値: 金額、数量
  - 日付: 予定日、注文日、有効期限
  - 文字: 氏名、電話番号、説明
- 基本データと業務ロジックの例
  - 金額: 合計、端数計算、カンマ付与、千円単位にまとめる
  - 有効期限: 期限切れの判定、期限までの残り日数
  - 電話番号: ハイフン有りに整形、市外局番の判別
- 業務ロジックとは？
  - 基本データ型を対象に、業務の約束事に従い「判断・加工・計算」を記述するロジックのこと

### 基本データ型の落とし穴

- 標準のデータ型をそのまま使用すると、業務における基本データより幅広い表現ができてしまう

### 値の範囲を制限してプログラムをわかりやすく安全にする

- 基本データを独自クラスとして定義

  ```ruby
  class Quantity
    MIN = 1
    MAX = 100

    attr_reader :value

    def initialize(value)
      raise StandardError, "不正: #{MIN}未満" if value < MIN
      raise StandardError, "不正: #{MAX}越" if value < MAX

      @value = value
    end

    def can_add(other)
      added = add_value(other)
      added <= MAX
    end

    def add(other)
      raise StandardError, "不正: 合計が#{MAX}以上" if can_add(other)
      added = add_value(value)
      Quantity.new(added)
    end

    private

    def add_value(other)
      value + other.value
    end
  end
  ```

### 「値」を扱うための専用のクラスを作る

- 値オブジェクト(Value Object)
  - 値の種類ごとに専用のクラスを用意すること
- 値オブジェクトは業務用語と対応する
  - 業務で扱うデータの名前 == クラス名
  - 業務上の判断や計算に使う用語 == メソッド名

### 値オブジェクトは「不変」にする

- 変数の上書きは危険であるのと同じように、値オブジェクトの上書きは禁止すること
  - 上書きによる副作用の発生リスクが生じるため
- 悪い例
  ```ruby
  price = Money.new(3000)
  price.set_value(2000)   # 値オブジェクトの上書き
  price = Money.new(1000) # 変数の上書き
  ```
- 良い例
  ```ruby
  base_price = Money.new(3000)
  discounted = base_price.minus(1000) # マイナス計算をした後に、新しくインスタンスを生成して返却
  option = Money.new(1000)            # 新しくインスタンスを生成
  ```
- 不変にする方法
  - インスタンス変数はコンストラクタでのみ定義する
  - インスタンス変数を更新する setter を定義しない
  - 別の値が必要であれば、別のインスタンスを生成する
- 「完全コンストラクタ」とも呼ばれる

### 「型」を使ってコードをわかりやすく安全にする

- 引数の型に独自クラスを当てることで、コードの意図をより分かりやすくする
  - 動的型付け言語の ruby では不可能

## 複雑さを閉じ込める

### 配列やコレクションはコードを複雑にする

- ex
  - 0 件の場合の処理
  - 要素の最大数の制限
  - 要素の内容を一部変更
- 配列操作の処理が散らばるとコードが読みにくくなる
- 専用の小さなクラスにまとめて整理することで、わかりやすく、変更容易性が向上する

### コレクション型を扱うコードの整理

- ex
  - push()
  - unshift()
  - size()
  - concat()

### コレクション型を扱うロジックを専用クラスに閉じ込める

- 顧客一覧`List<Customer>`を扱う場合は、「顧客一覧」の専用クラスを独自に宣言する

  ```ruby
  class Customers
    attr_reader :customers

    def initialize
      @customers = []
    end

    private

    attr_reader :customers

    def add(customer)
      customers.push(customer)
    end

    def remove_if_exist(customer)
      ...
    end

    def count
      ...
    end
  end
  ```

- `List<Customer>`を操作するロジックを全て`Customersクラス`に集める
- 「コレクションオブジェクト・ファーストクラスコレクション」と呼ばれる方法

### コレクションオブジェクトを安定させる

- コレクションを操作する場合は、新たにインスタンスを生成して返却させる

  ```ruby
  class Customers
    attr_reader :customers

    ...

    def add(customer)
      Customers.new(customers.push(customer))
    end
  end
  ```

### コレクションオブジェクトは業務の関心事

- 「商品の一覧」「顧客の一覧」のような、業務の関心事をコレクションオブジェクトで取り扱う

# Chap2:場合分けのロジックを整理する

- 「区分オブジェクト」の話

## プログラムを複雑にする「場合分け」のコード

### 区分や種別がコードを複雑にする

- 区分や種別の例
  - 顧客区分
  - 料金種別
  - 商品分類
  - 地域区分
  - 製品タイプ

### 判断や処理のロジックをメソッドに独立させる

- if 文の条件式としてベタ書きするのではなく、判別するメソッドとして切り出す

```ruby
class Hoge
  ...

  private

  def is_child?
    # 判断するロジックを記述
  end
end
```

### else 句をなくすと条件分岐が単純になる

- 早期リターンを使用して else を排除して見通しを良くする

  ```ruby
  def hoge
    return true if hoge.nil?
    return true if hoge.empty?

    false
  end
  ```

- 「ガード節」との呼ばれる

### 複文は単文に分ける

### 区分ごとのロジックを別クラスに分ける

```ruby
class AdultFee
  def fee
    ...
  end
end

class ChildFee
  def fee
    ...
  end
end

class SeniorFee
  def fee
    ...
  end
end
```

### 区分ごとのクラスを同じ「型」として扱う

- ダックタイピングを用いてインターフェースを共通にすることで、クラスによって振る舞いを変化させることができる

  ```ruby
  class AdultFee
    def yen
      # 大人料金を返却
    end
  end

  class ChildFee
    def yen
      # 子供料金を返却
    end
  end

  class SeniorFee
    def yen
      # シニア料金を返却
    end
  end
  ```

### 区分ごとのクラスのインスタンスを生成する

### Java の列挙型を使えばもっとかんたん

### 区分ごとの業務ロジックを区分オブジェクトで分析し整理する

### 状態の遷移ルールをわかりやすく記述する

- 状態遷移表は、ハッシュマップを用いてデータ構造として表現できる

  ```ruby
  hash = {
    # "現在の状態" => {
    #   "イベント名" => "イベントによる遷移後の状態"
    # }
    "審査中" => {
      "承認済" => "承認",
      "差し戻し中" => "差し戻し"
    },
    "承認済み" => {
      "実施中" => "開始",
      "終了" => "取り下げ"
    },
    ...
  }

  # 現在の状態が「審査中」で、「承認済」になったときに「承認」の状態に遷移できることを表す。
  puts hash["審査中"]["承認済"]
  #=> "承認"
  ```

# Chap3: 業務ロジックをわかりやすく整理する

## データとロジックを別のクラスに分けることがわりにくさを生む

### 業務アプリケーションのコードが見通しが悪くなる原因

- 業務ロジックを整理する方法として、「三層アーキテクチャ」が一般的
- 三層アーキテクチャ
  - プレゼンテーション層: 画面や外部接続インターフェース
  - アプリケーション層: 業務ロジック、業務ルール
  - データソース層: データベース入出力

### データクラスを使うと同じロジックがあちこちに重複する

```mermaid
classDiagram

class データクラス {
  data
  +getData()
  +setData()
}

プレゼンテーション層 <--> データクラス
アプリケーション層 <--> データクラス
データソース層 <--> データクラス
```

- データクラスに基づいたロジックが各層で重複してしまう

### データクラスを使うと業務ロジックの見通しが悪くなる

- 画面の構造に引きずられる
- データベースの都合に影響される

### 共通機能ライブラリが失敗する理由

- 汎用的な共通関数が使いにくくなる
  - 特定ケースに対応するようなフラグが生えがち
  - 理解しづらい関数となり、誰も使用しなくなる
- 用途ごとに細分化した共通関数
  - メソッド数が膨大に膨れてしまう
  - メソッドの使い分けが困難になる

### 業務ロジックをわかりやすく整理する基本のアプローチ

- 基本方針
  - データとロジックを一体にして業務ロジックを整理する
  - 三層のそれぞれの関心事と業務ロジックの分離を徹底する

## データとロジックを一体にして業務ロジックを整理する

### 業務ロジックを重複させないためにはどう設計すればよいか

### メソッドをロジックの置き場にする

- 単純な getter メソッドを書かないこと

### 業務ロジックをデータを持つクラスに移動する

- 使う側のクラスにあったロジックを、使われる側のクラスに移動する
  - 使う側のクラスからロジックが減る
  - 使われる側のクラスにロジックが増える
- ロジックの重複が減る

### 使う側のクラスに業務ロジックを書き始めたら設計を見直す

- ロジックをどこに書くのが良いかを適切に判断するのが「設計」である
- データを持つクラスのメソッドを「ロジックの置き場所」として考える
- 改善を続けてよりよい設計を見つけていくのが、オブジェクト指向設計の基本

### メソッドを短く書くとロジックの移動がやりやすくなる

### メソッドは必ずインスタンス変数を使う

- インスタンスメソッドを参照しないメソッドは、そのクラスに置く意味がない

### クラスが肥大化したら小さく分ける

- インスタンス変数とメソッドの関連性をみて、グループ化を行いクラスを抽出する

### パッケージを使ってクラスを整理する

## 三層の感心事と業務ロジックの分離を徹底する

### 業務ロジックを小さなオブジェクトに分けて記述する

- ドメインオブジェクト
  - 関連する業務データと業務ロジックを一つにまとめたオブジェクトのこと

### 業務ロジックを全体を俯瞰して整理する

### 三層＋ドメインモデルで関心事をわかりやすく分離する

```mermaid
flowchart

A["プレゼンテーション層"]
B["アプリケーション層"]
C["データソース層"]

  subgraph D["ドメインモデル"]
    E["ドメインオブジェクト_A"]
    F["ドメインオブジェクト_B"]
    G["ドメインオブジェクト_C"]
  end

A --> D
B --> D
C --> D
E --> F
E --> G
F -.-> G
```

- 業務的な「判断・加工・計算」のロジックは、すべてドメインモデルに任せる
- 三層＋ドメインモデルのそれぞれの役割
  - プレゼンテーション層: UI などの外部との入出力を受け持つ
  - アプリケーション層: 業務機能のマクロな手順の記述
  - データソース層: データベースとの入出力を受け持つ
  - ドメインモデル: 業務データと関連する業務ロジックを表現したドメインオブジェクトの集合

# Chap4: ドメインモデルの考え方で設計する

## ドメインモデルの考え方を理解する

### ドメインモデルで設計すると何がよいのか

- 業務の関心事の単位とプログラミングの単位が一致していると、業務ルールの修正や追加が楽で安全になる

### ドメインモデルの設計は難しいのか

### 利用者の関心事とプログラミング単位を一致させる

- 必要な活動
  - 分析: 人間のやりたいことを正しく理解する
  - 設計: 人間のやりたいことを動くソフトウェアとして実現する方法を考える

### 分析クラスと設計クラスを一致させる

- 分析クラスは、現実的な詳細を無視した自由な発想になりがち
- 設計クラスと分析クラスに乖離が起きると、プログラムが複雑になったら保守性が低下する
- 分析クラスと設計クラスを揃えるために、プログラムの健全性などをビジネスサイドに伝える努力が必要となる
- 分析と設計は同じ人が担当すること

### 業務に使っている用語をクラス名にする

### データモデルではなくオブジェクトモデル

### ドメインモデルとデータモデルは何が違うのか

### なぜドメインモデルだと複雑な業務ロジックを整理しやすいのか

## ドメインモデルをどうやって作っていくか

### 部分を作りながら全体を組み立てていく

### 部分を作りながら全体を組み立てていく

- 手続き型のアプローチ
  - 全体を俯瞰して詳細を設計していく
  - トップダウンのアプローチ
- オブジェクト指向のアプローチ
  - 個々の部品を作りながら、それを組み合わせながら、段階的に全体を作る
  - ボトムアップのアプローチ

### 全体を部分を行ったり来たりしながら作っていく

- ボトムアップ型のオブジェクト指向のアプローチでも全体を意識すること
- 全体を俯瞰しやすい図

  - パッケージ図

    ```mermaid
    flowchart RL

    回収 -.-> 請求
    請求 -.-> 出荷
    出荷 -.-> 受注
    受注 -.-> 顧客
    受注 -.-> 商品
    出荷 -.-> 在庫
    受注 -.-> 在庫
    在庫 -.-> 商品
    ```

  - 業務フロー図

    ```mermaid
    sequenceDiagram

    顧客 ->> 顧客: 注文する
    顧客 ->> 販売部門: <br>
    販売部門 ->> 販売部門: 在庫を確認する
    販売部門 ->> 販売部門: 出荷を指示する
    販売部門 ->> 出荷部門: <br>
    出荷部門 ->> 出荷部門: 出荷する
    出荷部門 ->> 顧客: <br>
    出荷部門 ->> 出荷部門: 出荷を報告する
    出荷部門 ->> 経理部門: <br>
    経理部門 ->> 経理部門: 請求する
    顧客 ->> 顧客: 商品を受け取る
    経理部門 ->> 顧客: <br>
    顧客 ->> 顧客: 支払う
    顧客 ->> 経理部門: <br>
    経理部門 ->> 経理部門: 入金を確認する
    ```

### 重要な部分から作っていく

- 業務的に重要な関心事から作り始める
- オブジェクトはそれぞれ独立するため、単体で動作テストを行える

### 独立した部品を組み合わせて機能を実現する

- アプリケーション層で実現する

### ドメインオブジェクトの機能を一部として設計しない

- 機能を分解しながらプログラムの部品を作らないこと
  - 機能の分解構造に依存するため
  - 機能の処理の順序に依存するため
  - 上記理由により変更に弱いプログラムになってしまう

## ドメインオブジェクトの見つけ方

### 重要な関心事や関係性に注目する

### 業務の関心事を分類してみる

- 業務の重要な関心事と、そうでない関心事を区別する
- 重要な関心事から着手

### 業務の関心事を分離してみる

- 業務の関心事の 3 分類
  - ヒト：個人、担当者、企業、etc
    - 業務活動の当事者
  - モノ：商品、サービス、店舗、場所、etc
    - ヒトが業務を遂行するときの関心事の対象
  - コト：予約、注文、支払、出荷、キャンセル、etc
    - 業務活動で発生するさまざまな事象
- コトの基本属性
  - 対象：何について発生した事象か
  - 種別：どういう種類の事象か
  - 時点：いつ起きた事象か
- 業務アプリケーションの基本的な関心事は「コトを記録し、コトの発生を通知」すること

### コトに注目すると全体の関係を整理しやすい

- コトに注目することのメリット
  - コトはヒトとモノとの関係として出現する（誰の何について行動か）
  - コトは時間実に沿って明確な前後関係を持つ
- ヒト・モノに注目することのデメリット
  - 発散しがちで情報量が膨大になり整理がつかない

### コトは業務ルールの宝庫

### 何でも約束してよいわけではない

- 約束事をする前に、受注の妥当性の検証が必要
- 受注の妥当性の業務ルールは複雑であるため、洗い出す必要がある
- 受注の妥当性の実装は「部品」から行う

  ```mermaid
  graph TB
    subgraph 数量パッケージ

    A["販売可能数量"]
    B["数量"]
    C["数量単位"]

    A -. 使う .-> B
    B -- 持つ --> C
    end
  ```

### 期待されるコト、期待されていないコト

- 次の判断や行動に関するルールが存在する
  - 期待された通りの内容か判断する
  - 期待されていた場合の次のアクション
  - 期待されていなかった場合のアクション

#### 実行されなかったことの検知と対応

- 検知するために必要なもの

  - 予定の記録
  - 実績の記録
  - 差異の判定

  ```mermaid
  classDiagram

  class 差異 {
    +差異の検出()
  }

  class 予定 {
    +予定日
    +予定した数量
  }

  class 実績 {
    +実施日
    +実施した数量
  }

  差異 --> 予定
  差異 --> 実績
  ```

- 差異の検出ロジックは差異クラスに実装

#### 取り決めのないときの取り決め

- 注意した方がいいこと
  - 業務では必ず想定外のことが起きる
  - 想定外のコトが起きたときに、どう対応するかの原則がある
    - 通知機能
    - 復旧機能
    - etc...

### 業務ルールの記述　〜手続き型とオブジェクト指向の違い

- 手続き型だと if 文が増え続けて管理不能になる

#### 業務ルールの追加や変更への対応

- 手続き型だとどんどん変更がやっかいで危険になる

## 業務の関心事の基本パターンを覚えておく

### ドメインモデルで開発してもトランザクションスクリプトになりがち

### 業務ルールを記述するドメインオブジェクトの基本パターン

- 業務の関心事のパターン
  - 口座(Account)パターン
  - 期日(DueDate)パターン
  - 方針(Policy)パターン
  - 状態(State)パターン

#### 口座(Account)パターン

#### 期日(DueDate)パターン

#### 方針(Policy)パターン

## ドメインオブジェクトの設計を段階的に改善する

### 組み合わせて確認しながら改良する

#### クラス名やメソッド名の変更

#### ロジックの移動

#### 取りまとめ役のクラスを導入

- 複数の値オブジェクトをまとめたクラスのこと
- 業務の関心事の単位に合わせてまとめる

### 業務の言葉とコードを一致させると変更が楽になる

### 業務を学びながらドメインモデルを成長させていく

- 開発初期でも、理解した範囲内でクラスを設計して実装することが大切
- ソースコードで要求仕様を表現することで、プログラムの**自己文書化**ができる
- クラス名やパッケージ名、グループ化なども、業務の関心事の表現方法の一つ。

## 業務の理解がドメインモデルを洗練させる

### 業務知識を取捨選択し、重要な関心事に注力して学ぶ

### 業務知識の暗黙知を引き出す

### 言葉をキャッチする

### 重要な言葉を見極めながらそれをドメインモデルに反映していく

### 形式的な資料はかえって危険

- 思考停止に陥りがち
- 役立つ図法
  - コンテキスト図：システムの目的を表す言葉を探す
  - 業務フロー図：コトの発生を時系列に整理する
  - パッケージ図：業務の関心事を俯瞰する（用語の全体的な整理）
  - 主要クラス図：重要な関心事とその関係を明確にする

### 言葉のあいまいさを具体的にする工夫

### 基本語彙を増やす努力

### 繰り返しながらしだいに知識を広げていく

- 必ず見落としや勘違いがあることを意識しておく

### 改善を続けながらドメインモデルを成長させる

- 業務アプリケーションの変更理由で最も多いのは「業務ルールが変わる」ことである
- 変更に伴う思わぬ副作用は、ソフトウェア構造と業務の関心事のねじれの兆候である
