# 概要<!-- omit in toc -->

- 書籍名
  - 現場で役立つシステム設計の原則

# 目次<!-- omit in toc -->

- [Chap1: 小さくまとめてわかりやすくする](#chap1-小さくまとめてわかりやすくする)
  - [なぜソフトウェアの変更は大変なのか](#なぜソフトウェアの変更は大変なのか)
    - [ソフトウェアの変更に立ち向かう](#ソフトウェアの変更に立ち向かう)
    - [変更が大変なプログラムの特徴](#変更が大変なプログラムの特徴)
    - [変更するたびに変更が大変になる](#変更するたびに変更が大変になる)
  - [プログラムの変更が楽になる書き方](#プログラムの変更が楽になる書き方)
    - [わかりやすい名前を使う](#わかりやすい名前を使う)
    - [長いメソッドは「段落」に分けて読みやすくする](#長いメソッドは段落に分けて読みやすくする)
    - [目的ごとに変数を用意する](#目的ごとに変数を用意する)
    - [メソッドとして独立させる](#メソッドとして独立させる)
    - [異なるクラスの重複したコードをなくす](#異なるクラスの重複したコードをなくす)
    - [狭い関心事に特化したクラスにする](#狭い関心事に特化したクラスにする)
    - [メソッドは短く、クラスは小さく](#メソッドは短くクラスは小さく)
  - [小さなクラスでわかりやすく安全に](#小さなクラスでわかりやすく安全に)
    - [データとロジック](#データとロジック)
    - [基本データ型の落とし穴](#基本データ型の落とし穴)
    - [値の範囲を制限してプログラムをわかりやすく安全にする](#値の範囲を制限してプログラムをわかりやすく安全にする)
    - [「値」を扱うための専用のクラスを作る](#値を扱うための専用のクラスを作る)
    - [値オブジェクトは「不変」にする](#値オブジェクトは不変にする)
    - [「型」を使ってコードをわかりやすく安全にする](#型を使ってコードをわかりやすく安全にする)
  - [複雑さを閉じ込める](#複雑さを閉じ込める)
    - [配列やコレクションはコードを複雑にする](#配列やコレクションはコードを複雑にする)
    - [コレクション型を扱うコードの整理](#コレクション型を扱うコードの整理)
    - [コレクション型を扱うロジックを専用クラスに閉じ込める](#コレクション型を扱うロジックを専用クラスに閉じ込める)
    - [コレクションオブジェクトを安定させる](#コレクションオブジェクトを安定させる)
    - [コレクションオブジェクトは業務の関心事](#コレクションオブジェクトは業務の関心事)
- [Chap2:場合分けのロジックを整理する](#chap2場合分けのロジックを整理する)
  - [プログラムを複雑にする「場合分け」のコード](#プログラムを複雑にする場合分けのコード)
    - [区分や種別がコードを複雑にする](#区分や種別がコードを複雑にする)
    - [判断や処理のロジックをメソッドに独立させる](#判断や処理のロジックをメソッドに独立させる)
    - [else 句をなくすと条件分岐が単純になる](#else-句をなくすと条件分岐が単純になる)
    - [複文は単文に分ける](#複文は単文に分ける)
    - [区分ごとのロジックを別クラスに分ける](#区分ごとのロジックを別クラスに分ける)
    - [区分ごとのクラスを同じ「型」として扱う](#区分ごとのクラスを同じ型として扱う)
    - [区分ごとのクラスのインスタンスを生成する](#区分ごとのクラスのインスタンスを生成する)
    - [Java の列挙型を使えばもっとかんたん](#java-の列挙型を使えばもっとかんたん)
    - [区分ごとの業務ロジックを区分オブジェクトで分析し整理する](#区分ごとの業務ロジックを区分オブジェクトで分析し整理する)
    - [状態の遷移ルールをわかりやすく記述する](#状態の遷移ルールをわかりやすく記述する)

# Chap1: 小さくまとめてわかりやすくする

## なぜソフトウェアの変更は大変なのか

### ソフトウェアの変更に立ち向かう

- 修正や拡張が楽で安全になるコードを生み出すのが設計
- クラス図や仕様書が必要であるわけではない
- ソースコードを整理整頓して、どこに何が書いてあるのかわかりやすくするのが設計
- プログラムの修正工数に大きく影響があるのが設計

### 変更が大変なプログラムの特徴

- 特徴一覧
  - メソッドが長い
  - クラスが大きい
  - 引数が多い
- 長いメソッド
  - 理解することが難しくバグが混入しやすい
- 大きなクラス
  - 関心ごとを詰め込みすぎている
- 引数が多いメソッド
  - 引数の関係の理解に時間がかかる
  - 処理が肥大化しやすい

### 変更するたびに変更が大変になる

- 元々はシンプルな実装であったが、小さな変更が積み重なり複雑化していく

## プログラムの変更が楽になる書き方

### わかりやすい名前を使う

- 意味の伝わらない省略形を使用しないこと

### 長いメソッドは「段落」に分けて読みやすくする

- 空白行でまとまりをつくる

  ```ruby
  price = quantity * unit_price

  price += 500 if price < 3000

  price = price * tax_rate
  ```

### 目的ごとに変数を用意する

- 同じ変数を使い回すことで可読性が落ちている
- 「説明用の変数の導入」と呼ばれる手法を用いて改善

  ```ruby
  base_price = quantity * unit_price

  shipping_cost = 0
  shipping_cost = 500 if base_price < 3000

  item_price = (base_price + shipping_cost) * tax_rate
  ```

- 同じ変数に代入し続ける方法は「破壊的代入」と呼ばれ、プログラム変更時の副作用によるバグが発生しやすい

### メソッドとして独立させる

- メソッド化することにより、変更の影響範囲をメソッド内に閉じ込めることができる

  ```ruby
  def shipping_cost(base_price)
  	return 500 if base_price < 3000

  	0
  end
  ```

- 「メソッドの抽出」と呼ばれる手法
  - メイン処理がシンプルになり可読性が向上
  - メソッド名からコードの意図が理解しやすい
  - メソッド内に変更の影響を閉じ込めやすくなる

### 異なるクラスの重複したコードをなくす

- 手順
  - 手順 1.
    - 重複コードでメソッドの抽出を行う
  - 手順 2. 異なるクラス間に参照関係がある場合
    - 参照先にメソッドを実装して、参照しているクラスから参照先のメソッドを呼び出す
  - 手順 2’. 異なるクラス間に参照関係がない場合
    - 共通メソッドの置き場所として新たにクラスを作成してメソッドを実装する
- クラスの置き場所については、ビジネスルールに基づく共通処理であるか、プログラムの都合上の共通処理であるのか、などに基づいてスコープを限定できる場所に配置

### 狭い関心事に特化したクラスにする

- 「送料クラス」では「送料」だけにする
- 「割引」などが発生する場合は、「割引」という関心ごとのクラスを新たに作成する
- 関心事に対応するクラスを「ドメインオブジェクト」と呼ぶ
  - 業務用ごと対応するドメインオブジェクトを用意することが OOP らしいアプローチである

### メソッドは短く、クラスは小さく

- メソッド名とクラス名を、業務の関心事、業務の用語と一致させることで、どこに何が記述されているのかわかりやすくする

## 小さなクラスでわかりやすく安全に

### データとロジック

- 業務アプリケーションの基本データ型
  - 数値: 金額、数量
  - 日付: 予定日、注文日、有効期限
  - 文字: 氏名、電話番号、説明
- 基本データと業務ロジックの例
  - 金額: 合計、端数計算、カンマ付与、千円単位にまとめる
  - 有効期限: 期限切れの判定、期限までの残り日数
  - 電話番号: ハイフン有りに整形、市外局番の判別
- 業務ロジックとは？
  - 基本データ型を対象に、業務の約束事に従い「判断・加工・計算」を記述するロジックのこと

### 基本データ型の落とし穴

- 標準のデータ型をそのまま使用すると、業務における基本データより幅広い表現ができてしまう

### 値の範囲を制限してプログラムをわかりやすく安全にする

- 基本データを独自クラスとして定義

  ```ruby
  class Quantity
    MIN = 1
    MAX = 100

    attr_reader :value

    def initialize(value)
      raise StandardError, "不正: #{MIN}未満" if value < MIN
      raise StandardError, "不正: #{MAX}越" if value < MAX

      @value = value
    end

    def can_add(other)
      added = add_value(other)
      added <= MAX
    end

    def add(other)
      raise StandardError, "不正: 合計が#{MAX}以上" if can_add(other)
      added = add_value(value)
      Quantity.new(added)
    end

    private

    def add_value(other)
      value + other.value
    end
  end
  ```

### 「値」を扱うための専用のクラスを作る

- 値オブジェクト(Value Object)
  - 値の種類ごとに専用のクラスを用意すること
- 値オブジェクトは業務用語と対応する
  - 業務で扱うデータの名前 == クラス名
  - 業務上の判断や計算に使う用語 == メソッド名

### 値オブジェクトは「不変」にする

- 変数の上書きは危険であるのと同じように、値オブジェクトの上書きは禁止すること
  - 上書きによる副作用の発生リスクが生じるため
- 悪い例
  ```ruby
  price = Money.new(3000)
  price.set_value(2000)   # 値オブジェクトの上書き
  price = Money.new(1000) # 変数の上書き
  ```
- 良い例
  ```ruby
  base_price = Money.new(3000)
  discounted = base_price.minus(1000) # マイナス計算をした後に、新しくインスタンスを生成して返却
  option = Money.new(1000)            # 新しくインスタンスを生成
  ```
- 不変にする方法
  - インスタンス変数はコンストラクタでのみ定義する
  - インスタンス変数を更新する setter を定義しない
  - 別の値が必要であれば、別のインスタンスを生成する
- 「完全コンストラクタ」とも呼ばれる

### 「型」を使ってコードをわかりやすく安全にする

- 引数の型に独自クラスを当てることで、コードの意図をより分かりやすくする
  - 動的型付け言語の ruby では不可能

## 複雑さを閉じ込める

### 配列やコレクションはコードを複雑にする

- ex
  - 0 件の場合の処理
  - 要素の最大数の制限
  - 要素の内容を一部変更
- 配列操作の処理が散らばるとコードが読みにくくなる
- 専用の小さなクラスにまとめて整理することで、わかりやすく、変更容易性が向上する

### コレクション型を扱うコードの整理

- ex
  - push()
  - unshift()
  - size()
  - concat()

### コレクション型を扱うロジックを専用クラスに閉じ込める

- 顧客一覧`List<Customer>`を扱う場合は、「顧客一覧」の専用クラスを独自に宣言する

  ```ruby
  class Customers
    attr_reader :customers

    def initialize
      @customers = []
    end

    private

    attr_reader :customers

    def add(customer)
      customers.push(customer)
    end

    def remove_if_exist(customer)
      ...
    end

    def count
      ...
    end
  end
  ```

- `List<Customer>`を操作するロジックを全て`Customersクラス`に集める
- 「コレクションオブジェクト・ファーストクラスコレクション」と呼ばれる方法

### コレクションオブジェクトを安定させる

- コレクションを操作する場合は、新たにインスタンスを生成して返却させる

  ```ruby
  class Customers
    attr_reader :customers

    ...

    def add(customer)
      Customers.new(customers.push(customer))
    end
  end
  ```

### コレクションオブジェクトは業務の関心事

- 「商品の一覧」「顧客の一覧」のような、業務の関心事をコレクションオブジェクトで取り扱う

# Chap2:場合分けのロジックを整理する

- 「区分オブジェクト」の話

## プログラムを複雑にする「場合分け」のコード

### 区分や種別がコードを複雑にする

- 区分や種別の例
  - 顧客区分
  - 料金種別
  - 商品分類
  - 地域区分
  - 製品タイプ

### 判断や処理のロジックをメソッドに独立させる

- if 文の条件式としてベタ書きするのではなく、判別するメソッドとして切り出す

```ruby
class Hoge
  ...

  private

  def is_child?
    # 判断するロジックを記述
  end
end
```

### else 句をなくすと条件分岐が単純になる

- 早期リターンを使用して else を排除して見通しを良くする

  ```ruby
  def hoge
    return true if hoge.nil?
    return true if hoge.empty?

    false
  end
  ```

- 「ガード節」との呼ばれる

### 複文は単文に分ける

### 区分ごとのロジックを別クラスに分ける

```ruby
class AdultFee
  def fee
    ...
  end
end

class ChildFee
  def fee
    ...
  end
end

class SeniorFee
  def fee
    ...
  end
end
```

### 区分ごとのクラスを同じ「型」として扱う

- ダックタイピングを用いてインターフェースを共通にすることで、クラスによって振る舞いを変化させることができる

  ```ruby
  class AdultFee
    def yen
      # 大人料金を返却
    end
  end

  class ChildFee
    def yen
      # 子供料金を返却
    end
  end

  class SeniorFee
    def yen
      # シニア料金を返却
    end
  end
  ```

### 区分ごとのクラスのインスタンスを生成する

### Java の列挙型を使えばもっとかんたん

### 区分ごとの業務ロジックを区分オブジェクトで分析し整理する

### 状態の遷移ルールをわかりやすく記述する

- 状態遷移表は、ハッシュマップを用いてデータ構造として表現できる

  ```ruby
  hash = {
    # "現在の状態" => {
    #   "イベント名" => "イベントによる遷移後の状態"
    # }
    "審査中" => {
      "承認済" => "承認",
      "差し戻し中" => "差し戻し"
    },
    "承認済み" => {
      "実施中" => "開始",
      "終了" => "取り下げ"
    },
    ...
  }

  # 現在の状態が「審査中」で、「承認済」になったときに「承認」の状態に遷移できることを表す。
  puts hash["審査中"]["承認済"]
  #=> "承認"
  ```
