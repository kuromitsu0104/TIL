# 概要<!-- omit in toc -->

- 書籍名
  - 現場で役立つシステム設計の原則

# 目次<!-- omit in toc -->

- [Chap1: 小さくまとめてわかりやすくする](#chap1-小さくまとめてわかりやすくする)
  - [なぜソフトウェアの変更は大変なのか](#なぜソフトウェアの変更は大変なのか)
    - [ソフトウェアの変更に立ち向かう](#ソフトウェアの変更に立ち向かう)
    - [変更が大変なプログラムの特徴](#変更が大変なプログラムの特徴)
    - [変更するたびに変更が大変になる](#変更するたびに変更が大変になる)
  - [プログラムの変更が楽になる書き方](#プログラムの変更が楽になる書き方)
    - [わかりやすい名前を使う](#わかりやすい名前を使う)
    - [長いメソッドは「段落」に分けて読みやすくする](#長いメソッドは段落に分けて読みやすくする)
    - [目的ごとに変数を用意する](#目的ごとに変数を用意する)
    - [メソッドとして独立させる](#メソッドとして独立させる)
    - [異なるクラスの重複したコードをなくす](#異なるクラスの重複したコードをなくす)
    - [狭い関心事に特化したクラスにする](#狭い関心事に特化したクラスにする)
    - [メソッドは短く、クラスは小さく](#メソッドは短くクラスは小さく)
  - [小さなクラスでわかりやすく安全に](#小さなクラスでわかりやすく安全に)
    - [データとロジック](#データとロジック)
    - [基本データ型の落とし穴](#基本データ型の落とし穴)
    - [値の範囲を制限してプログラムをわかりやすく安全にする](#値の範囲を制限してプログラムをわかりやすく安全にする)
    - [「値」を扱うための専用のクラスを作る](#値を扱うための専用のクラスを作る)
    - [値オブジェクトは「不変」にする](#値オブジェクトは不変にする)

# Chap1: 小さくまとめてわかりやすくする

## なぜソフトウェアの変更は大変なのか

### ソフトウェアの変更に立ち向かう

- 修正や拡張が楽で安全になるコードを生み出すのが設計
- クラス図や仕様書が必要であるわけではない
- ソースコードを整理整頓して、どこに何が書いてあるのかわかりやすくするのが設計
- プログラムの修正工数に大きく影響があるのが設計

### 変更が大変なプログラムの特徴

- 特徴一覧
  - メソッドが長い
  - クラスが大きい
  - 引数が多い
- 長いメソッド
  - 理解することが難しくバグが混入しやすい
- 大きなクラス
  - 関心ごとを詰め込みすぎている
- 引数が多いメソッド
  - 引数の関係の理解に時間がかかる
  - 処理が肥大化しやすい

### 変更するたびに変更が大変になる

- 元々はシンプルな実装であったが、小さな変更が積み重なり複雑化していく

## プログラムの変更が楽になる書き方

### わかりやすい名前を使う

- 意味の伝わらない省略形を使用しないこと

### 長いメソッドは「段落」に分けて読みやすくする

- 空白行でまとまりをつくる

  ```ruby
  price = quantity * unit_price

  price += 500 if price < 3000

  price = price * tax_rate
  ```

### 目的ごとに変数を用意する

- 同じ変数を使い回すことで可読性が落ちている
- 「説明用の変数の導入」と呼ばれる手法を用いて改善

  ```ruby
  base_price = quantity * unit_price

  shipping_cost = 0
  shipping_cost = 500 if base_price < 3000

  item_price = (base_price + shipping_cost) * tax_rate
  ```

- 同じ変数に代入し続ける方法は「破壊的代入」と呼ばれ、プログラム変更時の副作用によるバグが発生しやすい

### メソッドとして独立させる

- メソッド化することにより、変更の影響範囲をメソッド内に閉じ込めることができる

  ```ruby
  def shipping_cost(base_price)
  	return 500 if base_price < 3000

  	0
  end
  ```

- 「メソッドの抽出」と呼ばれる手法
  - メイン処理がシンプルになり可読性が向上
  - メソッド名からコードの意図が理解しやすい
  - メソッド内に変更の影響を閉じ込めやすくなる

### 異なるクラスの重複したコードをなくす

- 手順
  - 手順 1.
    - 重複コードでメソッドの抽出を行う
  - 手順 2. 異なるクラス間に参照関係がある場合
    - 参照先にメソッドを実装して、参照しているクラスから参照先のメソッドを呼び出す
  - 手順 2’. 異なるクラス間に参照関係がない場合
    - 共通メソッドの置き場所として新たにクラスを作成してメソッドを実装する
- クラスの置き場所については、ビジネスルールに基づく共通処理であるか、プログラムの都合上の共通処理であるのか、などに基づいてスコープを限定できる場所に配置

### 狭い関心事に特化したクラスにする

- 「送料クラス」では「送料」だけにする
- 「割引」などが発生する場合は、「割引」という関心ごとのクラスを新たに作成する
- 関心事に対応するクラスを「ドメインオブジェクト」と呼ぶ
  - 業務用ごと対応するドメインオブジェクトを用意することが OOP らしいアプローチである

### メソッドは短く、クラスは小さく

- メソッド名とクラス名を、業務の関心事、業務の用語と一致させることで、どこに何が記述されているのかわかりやすくする

## 小さなクラスでわかりやすく安全に

### データとロジック

- 業務アプリケーションの基本データ型
  - 数値: 金額、数量
  - 日付: 予定日、注文日、有効期限
  - 文字: 氏名、電話番号、説明
- 基本データと業務ロジックの例
  - 金額: 合計、端数計算、カンマ付与、千円単位にまとめる
  - 有効期限: 期限切れの判定、期限までの残り日数
  - 電話番号: ハイフン有りに整形、市外局番の判別
- 業務ロジックとは？
  - 基本データ型を対象に、業務の約束事に従い「判断・加工・計算」を記述するロジックのこと

### 基本データ型の落とし穴

- 標準のデータ型をそのまま使用すると、業務における基本データより幅広い表現ができてしまう

### 値の範囲を制限してプログラムをわかりやすく安全にする

- 基本データを独自クラスとして定義

  ```ruby
  class Quantity
    MIN = 1
    MAX = 100

    attr_reader :value

    def initialize(value)
      raise StandardError, "不正: #{MIN}未満" if value < MIN
      raise StandardError, "不正: #{MAX}越" if value < MAX

      @value = value
    end

    def can_add(other)
      added = add_value(other)
      added <= MAX
    end

    def add(other)
      raise StandardError, "不正: 合計が#{MAX}以上" if can_add(other)
      added = add_value(value)
      Quantity.new(added)
    end

    private

    def add_value(other)
      value + other.value
    end
  end
  ```

### 「値」を扱うための専用のクラスを作る

- 値オブジェクト(Value Object)
  - 値の種類ごとに専用のクラスを用意すること
- 値オブジェクトは業務用語と対応する
  - 業務で扱うデータの名前 == クラス名
  - 業務上の判断や計算に使う用語 == メソッド名

### 値オブジェクトは「不変」にする

- 変数の上書きは危険であるのと同じように、値オブジェクトの上書きは禁止すること
  - 上書きによる副作用の発生リスクが生じるため
- 悪い例
  ```ruby
  price = Money.new(3000)
  price.set_value(2000)   # 値オブジェクトの上書き
  price = Money.new(1000) # 変数の上書き
  ```
- 良い例
  ```ruby
  base_price = Money.new(3000)
  discounted = base_price.minus(1000) # マイナス計算をした後に、新しくインスタンスを生成して返却
  option = Money.new(1000)            # 新しくインスタンスを生成
  ```
- 不変にする方法
  - インスタンス変数はコンストラクタでのみ定義する
  - インスタンス変数を更新する setter を定義しない
  - 別の値が必要であれば、別のインスタンスを生成する
- 「完全コンストラクタ」とも呼ばれる
